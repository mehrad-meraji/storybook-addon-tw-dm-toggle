#!/usr/bin/env node
"use strict";
/* eslint-disable complexity */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCli = exports.execute = void 0;
const tslib_1 = require("tslib");
const core_1 = tslib_1.__importStar(require("@auto-it/core"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
/** Spin up the "auto" node API and provide it the parsed CLI args. */
async function execute(command, args) {
    var _a, _b;
    const auto = new core_1.default(args);
    try {
        if (command === "init") {
            await auto.init();
            return;
        }
        await auto.loadConfig();
        if (args.verbose || command === "info") {
            try {
                // We don't want auto.info throwing an error during another
                // command
                const { hasError } = await auto.info(args);
                if (command === "info") {
                    // eslint-disable-next-line max-depth
                    if (hasError) {
                        process.exit(1);
                    }
                    else {
                        return;
                    }
                }
            }
            catch (error) {
                if (command === "info") {
                    process.exit(1);
                }
            }
        }
        switch (command) {
            case "create-labels":
                await auto.createLabels(args);
                break;
            case "label":
                await auto.label(args);
                break;
            case "pr-check":
                await auto.prCheck(args);
                break;
            case "pr-status":
                await auto.prStatus(args);
                break;
            case "comment":
                await auto.comment(args);
                break;
            case "pr-body":
                await auto.prBody(args);
                break;
            case "version":
                await auto.version(args);
                break;
            case "changelog":
                await auto.changelog(args);
                break;
            case "release":
                await auto.runRelease(args);
                break;
            case "shipit":
                await auto.shipit(args);
                break;
            case "latest":
                await auto.latest(args);
                break;
            case "canary":
                await auto.canary(args);
                break;
            case "next":
                await auto.next(args);
                break;
            default:
                throw new Error(`idk what i'm doing.`);
        }
    }
    catch (error) {
        if (error.status === 404) {
            const [, project] = await await_to_js_1.default(auto.git.getProject());
            const repoLink = terminal_link_1.default(`${(_a = auto.git) === null || _a === void 0 ? void 0 : _a.options.owner}/${(_b = auto.git) === null || _b === void 0 ? void 0 : _b.options.repo}`, (project === null || project === void 0 ? void 0 : project.html_url) || "");
            auto.logger.log.error(endent_1.default `
        Received 404!

        This usually because the GitHub token you're using doesn't have the correct permissions to the repo.
        
        The token used with auto must have at least "write" permission to your repo (${repoLink}) to create releases and labels.

        You can check the permission for your token by running "auto info".
      `);
            console.log("");
            auto.logger.verbose.error(error);
        }
        else if (error.message.includes("TypeError: Cannot read property 'tap")) {
            auto.logger.log.error(endent_1.default `
        One of the plugins you're using calls an unknown hook!

        This usually because your project is trying to use mismatched plugin + core version.
        
        To fix this do one of the following:

        1. Ensure that you have the same version of auto and it's plugins installed
        2. Ensure that any non-official plugins use the same version of @auto-it/core
        3. Ensure your environment's version of auto matches the plugins you're using
      `);
            auto.logger.log.error(error);
        }
        else if (!(error instanceof core_1.LabelExistsError)) {
            console.log(error);
        }
        process.exit(1);
    }
    finally {
        await auto.teardown();
    }
}
exports.execute = execute;
/** Run "auto" for a given command. */
async function runCli(command, args) {
    await execute(command, args);
}
exports.runCli = runCli;
//# sourceMappingURL=run.js.map