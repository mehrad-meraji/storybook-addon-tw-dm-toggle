import * as t from "io-ts";
import { ILabelDefinition } from "./semver";
declare const author: t.PartialC<{
    /** The name and email of the author to make commits with */
    author: t.UnionC<[t.StringC, t.TypeC<{
        /** The name of the author to make commits with */ name: t.StringC;
        /** The email of the author to make commits with */
        email: t.StringC;
    }>]>;
    /** The name of the author to make commits with */
    name: t.StringC;
    /** The email of the author to make commits with */
    email: t.StringC;
}>;
export declare type AuthorInformation = t.TypeOf<typeof author>;
declare const githubInformation: t.PartialC<{
    /** The github api to interact with */
    githubApi: t.StringC;
    /** The github graphql api to interact with */
    githubGraphqlApi: t.StringC;
    /** The branch that is used as the base */
    baseBranch: t.StringC;
}>;
export declare type GithubInformation = t.TypeOf<typeof githubInformation>;
declare const repoInformation: t.PartialC<{
    /** The repo of to publish, might be set in package manager file. */
    repo: t.StringC;
    /** The owner of the repo to publish, might be set in package manager file. */
    owner: t.StringC;
}>;
export declare type RepoInformation = t.TypeOf<typeof repoInformation>;
export declare type PluginConfig = [string, any] | string;
declare const releaseCalculationOptions: t.PartialC<{
    /** Instead of publishing every PR only publish when "release" label is present */
    onlyPublishWithReleaseLabel: t.BooleanC;
}>;
export declare type ReleaseCalculationOptions = t.TypeOf<typeof releaseCalculationOptions>;
declare const logOptions: t.PartialC<{
    /** Show more logs */
    verbose: t.UnionC<[t.BooleanC, t.TupleC<[t.BooleanC, t.BooleanC]>]>;
}>;
export declare type LogOptions = t.TypeOf<typeof logOptions>;
export declare const globalOptions: t.PartialC<{
    /** Another auto configuration to extend */
    extends: t.StringC;
    /** Labels that power auto */
    labels: t.ArrayC<t.IntersectionC<[t.PartialC<{
        changelogTitle: t.StringC;
        color: t.StringC;
        description: t.StringC;
        releaseType: t.UnionC<[t.LiteralC<"none">, t.LiteralC<"skip">, ...t.LiteralC<import("./semver").VersionLabel>[]]>;
        overwrite: t.BooleanC;
        default: t.BooleanC;
    }>, t.TypeC<{
        name: t.StringC;
    }>]>>;
    /** Don't add default labels */
    noDefaultLabels: t.BooleanC;
    /** Branches to create pre-releases from */
    prereleaseBranches: t.ArrayC<t.StringC>;
    /** Configured auto plugins */
    plugins: t.ArrayC<t.UnionC<[t.StringC, t.TupleC<[t.StringC, t.AnyC]>]>>;
    /** Whether to prefix the version with a "v" */
    noVersionPrefix: t.BooleanC;
    /**
     * Manage old version branches.
     * Can be a true or a custom version branch prefix.
     *
     * @default 'version-'
     */
    versionBranches: t.UnionC<[t.BooleanC, t.StringC]>;
    /** Options to pass to "auto comment" */
    comment: t.PartialC<{
        /** Delete the previous comment */
        delete: t.BooleanC;
        /** Instead of deleting/adding a new comment. Just edit the old one */
        edit: t.BooleanC;
    }>;
    /** Options to pass to "auto changelog" */
    changelog: t.PartialC<{
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto release" */
    release: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
    }>;
    /** Options to pass to "auto shipit" */
    shipit: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
        /**
         * Make auto publish prerelease versions when merging to baseBranch.
         * Only PRs merged with "release" label will generate a "latest" release.
         * Only use this flag if you do not want to maintain a prerelease branch,
         * and instead only want to use baseBranch.
         */
        onlyGraduateWithReleaseLabel: t.BooleanC;
    }>;
    /** Options to pass to "auto latest" */
    latest: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto canary" */
    canary: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the canary version to a PR */
        message: t.UnionC<[t.LiteralC<false>, t.StringC]>;
        /** How the canary version should be attached to a PR */
        target: t.UnionC<[t.LiteralC<"pr-body">, t.LiteralC<"comment">, t.LiteralC<"status">]>;
    }>;
    /** Options to pass to "auto next" */
    next: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the prerelease version to a PR */
        message: t.StringC;
    }>;
}>;
export declare type GlobalOptions = t.TypeOf<typeof globalOptions>;
export declare const autoRc: t.IntersectionC<[t.PartialC<{
    /** Another auto configuration to extend */
    extends: t.StringC;
    /** Labels that power auto */
    labels: t.ArrayC<t.IntersectionC<[t.PartialC<{
        changelogTitle: t.StringC;
        color: t.StringC;
        description: t.StringC;
        releaseType: t.UnionC<[t.LiteralC<"none">, t.LiteralC<"skip">, ...t.LiteralC<import("./semver").VersionLabel>[]]>;
        overwrite: t.BooleanC;
        default: t.BooleanC;
    }>, t.TypeC<{
        name: t.StringC;
    }>]>>;
    /** Don't add default labels */
    noDefaultLabels: t.BooleanC;
    /** Branches to create pre-releases from */
    prereleaseBranches: t.ArrayC<t.StringC>;
    /** Configured auto plugins */
    plugins: t.ArrayC<t.UnionC<[t.StringC, t.TupleC<[t.StringC, t.AnyC]>]>>;
    /** Whether to prefix the version with a "v" */
    noVersionPrefix: t.BooleanC;
    /**
     * Manage old version branches.
     * Can be a true or a custom version branch prefix.
     *
     * @default 'version-'
     */
    versionBranches: t.UnionC<[t.BooleanC, t.StringC]>;
    /** Options to pass to "auto comment" */
    comment: t.PartialC<{
        /** Delete the previous comment */
        delete: t.BooleanC;
        /** Instead of deleting/adding a new comment. Just edit the old one */
        edit: t.BooleanC;
    }>;
    /** Options to pass to "auto changelog" */
    changelog: t.PartialC<{
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto release" */
    release: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
    }>;
    /** Options to pass to "auto shipit" */
    shipit: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
        /**
         * Make auto publish prerelease versions when merging to baseBranch.
         * Only PRs merged with "release" label will generate a "latest" release.
         * Only use this flag if you do not want to maintain a prerelease branch,
         * and instead only want to use baseBranch.
         */
        onlyGraduateWithReleaseLabel: t.BooleanC;
    }>;
    /** Options to pass to "auto latest" */
    latest: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto canary" */
    canary: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the canary version to a PR */
        message: t.UnionC<[t.LiteralC<false>, t.StringC]>;
        /** How the canary version should be attached to a PR */
        target: t.UnionC<[t.LiteralC<"pr-body">, t.LiteralC<"comment">, t.LiteralC<"status">]>;
    }>;
    /** Options to pass to "auto next" */
    next: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the prerelease version to a PR */
        message: t.StringC;
    }>;
}>, t.IntersectionC<[t.PartialC<{
    /** The repo of to publish, might be set in package manager file. */
    repo: t.StringC;
    /** The owner of the repo to publish, might be set in package manager file. */
    owner: t.StringC;
}>, t.PartialC<{
    /** The github api to interact with */
    githubApi: t.StringC;
    /** The github graphql api to interact with */
    githubGraphqlApi: t.StringC;
    /** The branch that is used as the base */
    baseBranch: t.StringC;
}>, t.PartialC<{
    /** The name and email of the author to make commits with */
    author: t.UnionC<[t.StringC, t.TypeC<{
        /** The name of the author to make commits with */ name: t.StringC;
        /** The email of the author to make commits with */
        email: t.StringC;
    }>]>;
    /** The name of the author to make commits with */
    name: t.StringC;
    /** The email of the author to make commits with */
    email: t.StringC;
}>, t.PartialC<{
    /** Instead of publishing every PR only publish when "release" label is present */
    onlyPublishWithReleaseLabel: t.BooleanC;
}>, t.PartialC<{
    /** Show more logs */
    verbose: t.UnionC<[t.BooleanC, t.TupleC<[t.BooleanC, t.BooleanC]>]>;
}>]>]>;
export declare type AutoRc = t.TypeOf<typeof autoRc> & {
    /** Labels that power auto */
    labels?: ILabelDefinition[];
};
export declare const loadedAutoRc: t.IntersectionC<[t.IntersectionC<[t.PartialC<{
    /** Another auto configuration to extend */
    extends: t.StringC;
    /** Labels that power auto */
    labels: t.ArrayC<t.IntersectionC<[t.PartialC<{
        changelogTitle: t.StringC;
        color: t.StringC;
        description: t.StringC;
        releaseType: t.UnionC<[t.LiteralC<"none">, t.LiteralC<"skip">, ...t.LiteralC<import("./semver").VersionLabel>[]]>;
        overwrite: t.BooleanC;
        default: t.BooleanC;
    }>, t.TypeC<{
        name: t.StringC;
    }>]>>;
    /** Don't add default labels */
    noDefaultLabels: t.BooleanC;
    /** Branches to create pre-releases from */
    prereleaseBranches: t.ArrayC<t.StringC>;
    /** Configured auto plugins */
    plugins: t.ArrayC<t.UnionC<[t.StringC, t.TupleC<[t.StringC, t.AnyC]>]>>;
    /** Whether to prefix the version with a "v" */
    noVersionPrefix: t.BooleanC;
    /**
     * Manage old version branches.
     * Can be a true or a custom version branch prefix.
     *
     * @default 'version-'
     */
    versionBranches: t.UnionC<[t.BooleanC, t.StringC]>;
    /** Options to pass to "auto comment" */
    comment: t.PartialC<{
        /** Delete the previous comment */
        delete: t.BooleanC;
        /** Instead of deleting/adding a new comment. Just edit the old one */
        edit: t.BooleanC;
    }>;
    /** Options to pass to "auto changelog" */
    changelog: t.PartialC<{
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto release" */
    release: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
    }>;
    /** Options to pass to "auto shipit" */
    shipit: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
        /**
         * Make auto publish prerelease versions when merging to baseBranch.
         * Only PRs merged with "release" label will generate a "latest" release.
         * Only use this flag if you do not want to maintain a prerelease branch,
         * and instead only want to use baseBranch.
         */
        onlyGraduateWithReleaseLabel: t.BooleanC;
    }>;
    /** Options to pass to "auto latest" */
    latest: t.PartialC<{
        /** Create a prerelease */
        prerelease: t.BooleanC;
        /** Skip creating the changelog */
        noChangelog: t.BooleanC;
        /** The commit message to commit the changelog changes with */
        message: t.StringC;
    }>;
    /** Options to pass to "auto canary" */
    canary: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the canary version to a PR */
        message: t.UnionC<[t.LiteralC<false>, t.StringC]>;
        /** How the canary version should be attached to a PR */
        target: t.UnionC<[t.LiteralC<"pr-body">, t.LiteralC<"comment">, t.LiteralC<"status">]>;
    }>;
    /** Options to pass to "auto next" */
    next: t.PartialC<{
        /** Always deploy even if marked as skip release */
        force: t.BooleanC;
        /** The message used when attaching the prerelease version to a PR */
        message: t.StringC;
    }>;
}>, t.IntersectionC<[t.PartialC<{
    /** The repo of to publish, might be set in package manager file. */
    repo: t.StringC;
    /** The owner of the repo to publish, might be set in package manager file. */
    owner: t.StringC;
}>, t.PartialC<{
    /** The github api to interact with */
    githubApi: t.StringC;
    /** The github graphql api to interact with */
    githubGraphqlApi: t.StringC;
    /** The branch that is used as the base */
    baseBranch: t.StringC;
}>, t.PartialC<{
    /** The name and email of the author to make commits with */
    author: t.UnionC<[t.StringC, t.TypeC<{
        /** The name of the author to make commits with */ name: t.StringC;
        /** The email of the author to make commits with */
        email: t.StringC;
    }>]>;
    /** The name of the author to make commits with */
    name: t.StringC;
    /** The email of the author to make commits with */
    email: t.StringC;
}>, t.PartialC<{
    /** Instead of publishing every PR only publish when "release" label is present */
    onlyPublishWithReleaseLabel: t.BooleanC;
}>, t.PartialC<{
    /** Show more logs */
    verbose: t.UnionC<[t.BooleanC, t.TupleC<[t.BooleanC, t.BooleanC]>]>;
}>]>]>, t.TypeC<{
    /** Labels that power auto */
    labels: t.ArrayC<t.IntersectionC<[t.PartialC<{
        changelogTitle: t.StringC;
        color: t.StringC;
        description: t.StringC;
        releaseType: t.UnionC<[t.LiteralC<"none">, t.LiteralC<"skip">, ...t.LiteralC<import("./semver").VersionLabel>[]]>;
        overwrite: t.BooleanC;
        default: t.BooleanC;
    }>, t.TypeC<{
        name: t.StringC;
    }>]>>;
    /** Branches to create pre-releases from */
    prereleaseBranches: t.ArrayC<t.StringC>;
    /** The branch that is used as the base */
    baseBranch: t.StringC;
}>]>;
export declare type LoadedAutoRc = t.TypeOf<typeof loadedAutoRc>;
export {};
//# sourceMappingURL=types.d.ts.map