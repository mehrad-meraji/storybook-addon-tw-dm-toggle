import { RestEndpointMethodTypes } from "@octokit/rest";
import { AsyncParallelHook, AsyncSeriesBailHook, SyncHook, AsyncSeriesHook, AsyncSeriesWaterfallHook } from "tapable";
import { ApiOptions, IInfoOptions, ICanaryOptions, IChangelogOptions, ICommentOptions, ICreateLabelsOptions, ILabelOptions, IPRCheckOptions, IPRStatusOptions, IReleaseOptions, IShipItOptions, IVersionOptions, INextOptions, QuietOption, DryRunOption } from "./auto-args";
import Changelog from "./changelog";
import Git from "./git";
import LogParse, { IExtendedCommit } from "./log-parse";
import Release from "./release";
import SEMVER, { IVersionLabels, ILabelDefinition } from "./semver";
import { ILogger } from "./utils/logger";
import { RepoInformation, AuthorInformation, LoadedAutoRc } from "./types";
import { ValidatePluginHook } from "./validate-config";
interface ChangelogLifecycle {
    /** The bump being applied to the version */
    bump: SEMVER;
    /** The commits included in the changelog */
    commits: IExtendedCommit[];
    /** The generated release notes for the commits */
    releaseNotes: string;
    /** The current version of the project */
    currentVersion: string;
    /** The last version of the project */
    lastRelease: string;
}
interface TestingToken {
    /** A token used for testing */
    token?: string;
}
declare type ShipitContext = "canary" | "next" | "latest" | "old";
interface ShipitInfo {
    /** The Version published when shipit ran */
    newVersion?: string;
    /** The commits released during shipit */
    commitsInRelease: IExtendedCommit[];
    /** The type of release made */
    context: ShipitContext;
}
export declare type ShipitRelease = "latest" | "old" | "next" | "canary";
interface BeforeShipitContext extends DryRunOption {
    /** The type of release that will be made when shipit runs. */
    releaseType: ShipitRelease;
}
interface NextContext extends DryRunOption {
    /** The bump to apply to the version */
    bump: SEMVER;
    /** The commits in the next release */
    commits: IExtendedCommit[];
    /** The release notes for all the commits in the next release */
    fullReleaseNotes: string;
    /** The release notes for the last change merged to the next release */
    releaseNotes: string;
}
declare type PublishResponse = RestEndpointMethodTypes["repos"]["createRelease"]["response"];
export interface IAutoHooks {
    /** Modify what is in the config. You must return the config in this hook. */
    modifyConfig: AsyncSeriesWaterfallHook<[LoadedAutoRc]>;
    /** Validate what is in the config. You must return the config in this hook. */
    validateConfig: ValidatePluginHook;
    /** Happens before anything is done. This is a great place to check for platform specific secrets. */
    beforeRun: AsyncSeriesHook<[LoadedAutoRc]>;
    /** Happens after everything else is done. This is a great place to trigger post-actions. */
    afterRun: AsyncSeriesHook<[LoadedAutoRc]>;
    /** Happens before `shipit` is run. This is a great way to throw an error if a token or key is not present. */
    beforeShipIt: AsyncSeriesHook<[BeforeShipitContext]>;
    /** Ran before the `changelog` command commits the new release notes to `CHANGELOG.md`. */
    beforeCommitChangelog: AsyncSeriesHook<[ChangelogLifecycle]>;
    /** Ran after the `changelog` command adds the new release notes to `CHANGELOG.md`. */
    afterChangelog: AsyncSeriesHook<[ChangelogLifecycle]>;
    /** Ran after the `shipit` command has run. */
    afterShipIt: AsyncParallelHook<[
        DryRunOption & {
            /** The version published in the shipit run */
            newVersion: string | undefined;
            /** The commits the version was published for */
            commitsInRelease: IExtendedCommit[];
            /** The type of release made by shipit */
            context: ShipitContext;
        }
    ]>;
    /** Ran after the `release` command has run. */
    afterRelease: AsyncParallelHook<[
        {
            /** The last version released */
            lastRelease: string;
            /** The version being released */
            newVersion?: string;
            /** The commits included in the release */
            commits: IExtendedCommit[];
            /** The generated release notes for the commits */
            releaseNotes: string;
            /** The response from creating the new release. */
            response?: PublishResponse | PublishResponse[];
        }
    ]>;
    /** Override what happens when "releasing" code to a Github release */
    makeRelease: AsyncSeriesBailHook<[
        DryRunOption & {
            /** Commit to start calculating the version from */
            from: string;
            /** Commit to end calculating the version from */
            to: string;
            /** Override the version to release */
            useVersion?: string;
            /** The version being released */
            newVersion: string;
            /** Whether the release being made is a prerelease */
            isPrerelease?: boolean;
            /** The generated release notes for the commits */
            fullReleaseNotes: string;
            /** The commits included in the release */
            commits: IExtendedCommit[];
        }
    ], PublishResponse | PublishResponse[] | void>;
    /** Get git author. Typically from a package distribution description file. */
    getAuthor: AsyncSeriesBailHook<[], Partial<AuthorInformation> | void>;
    /** Get the previous version. Typically from a package distribution description file. */
    getPreviousVersion: AsyncSeriesBailHook<[], string>;
    /** Get owner and repository. Typically from a package distribution description file. */
    getRepository: AsyncSeriesBailHook<[
    ], (RepoInformation & TestingToken) | void>;
    /** Tap into the things the Release class makes. This isn't the same as `auto release`, but the main class that does most of the work. */
    onCreateRelease: SyncHook<[Release]>;
    /**
     * This is where you hook into the LogParse's hooks.
     * This hook is exposed for convenience during `this.hooks.onCreateRelease` and at the root `this.hooks`
     */
    onCreateLogParse: SyncHook<[LogParse]>;
    /**
     * This is where you hook into the changelog's hooks.
     * This hook is exposed for convenience during `this.hooks.onCreateRelease` and at the root `this.hooks`
     */
    onCreateChangelog: SyncHook<[
        Changelog,
        {
            /** The bump the changelog will make */
            bump: SEMVER | undefined;
        }
    ]>;
    /** Ran before the package has been versioned. */
    beforeVersion: AsyncSeriesHook<[
        DryRunOption & {
            /** Commit to start calculating the version from */
            from: string;
            /** The commits included in the release */
            commits: IExtendedCommit[];
        }
    ]>;
    /** Version the package. This is a good opportunity to `git tag` the release also.  */
    version: AsyncSeriesHook<[
        DryRunOption & QuietOption & {
            /** The semver bump to apply */
            bump: SEMVER;
            /** Override the version to release */
            useVersion?: string;
        }
    ]>;
    /** Ran after the package has been versioned. */
    afterVersion: AsyncSeriesHook<[DryRunOption]>;
    /** Publish the package to some package distributor. You must push the tags to github! */
    publish: AsyncSeriesHook<[
        {
            /** The semver bump that was applied in the version hook */
            bump: SEMVER;
            /** Override the version to release */
            useVersion?: string;
        }
    ]>;
    /** Used to publish a canary release. In this hook you get the semver bump and the unique canary postfix ID. */
    canary: AsyncSeriesBailHook<[
        DryRunOption & QuietOption & {
            /** The bump being applied to the version */
            bump: SEMVER;
            /** The post-version identifier to add to the version */
            canaryIdentifier: string;
        }
    ], string | {
        /** A summary to use in a details html element */
        newVersion: string;
        /** The details to use in a details html element */
        details: string;
    } | {
        /** Error when creating the canary release */
        error: string;
    } | void>;
    /**
     * Used to publish a next release. In this hook you get the semver bump
     * and an array of next versions that been released. If you make another
     * next release be sure to add it the the array.
     */
    next: AsyncSeriesWaterfallHook<[string[], NextContext]>;
    /** Ran after the package has been published. */
    afterPublish: AsyncSeriesHook<[]>;
    /** Ran after the package has been published. */
    prCheck: AsyncSeriesHook<[
        DryRunOption & {
            /** The complete information about the PR */
            pr: RestEndpointMethodTypes["pulls"]["get"]["response"]["data"];
        }
    ]>;
}
/** Get the pr number from user input or the CI env. */
export declare function getPrNumberFromEnv(pr?: number): number | false;
/**
 * Bump the version but no too much.
 *
 * @example
 * currentVersion = 1.0.0
 * nextVersion = 2.0.0-next.0
 * output = 2.0.0-next.1
 */
export declare function determineNextVersion(lastVersion: string, currentVersion: string, bump: SEMVER, tag?: string): string;
/** Print the current version of "auto" */
export declare function getAutoVersion(): any;
/** The Error that gets thrown when a label existence check fails */
export declare class LabelExistsError extends Error {
    /**
     * @param label - the label we were checking existence for
     */
    constructor(label: string);
}
/**
 * The "auto" node API. Its public interface matches the
 * commands you can run from the CLI
 */
export default class Auto {
    /** Plugin entry points */
    hooks: IAutoHooks;
    /** A logger that uses log levels */
    logger: ILogger;
    /** Options auto was initialized with */
    options: ApiOptions;
    /** The branch auto uses as the base. */
    baseBranch: string;
    /** The remote git to push changes to. This is the full URL with auth */
    remote: string;
    /** The user configuration of auto (.autorc) */
    config?: LoadedAutoRc;
    /** A class that handles creating releases */
    release?: Release;
    /** A class that handles interacting with git and GitHub */
    git?: Git;
    /** The labels configured by the user */
    labels?: ILabelDefinition[];
    /** A map of semver bumps to labels that signify those bumps */
    semVerLabels?: IVersionLabels;
    /** The version bump being used during "shipit" */
    private versionBump?;
    /** Initialize auto and it's environment */
    constructor(options?: ApiOptions);
    /** List some of the plugins available to auto */
    private listPlugins;
    /**
     * Load the default hook behaviors. Should run after loadPlugins so
     * plugins take precedence.
     */
    private loadDefaultBehavior;
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    loadConfig(): Promise<{
        baseBranch: string;
        extends?: string | undefined;
        labels: ({
            changelogTitle?: string | undefined;
            color?: string | undefined;
            description?: string | undefined;
            releaseType?: import("./semver").VersionLabel | "none" | undefined;
            overwrite?: boolean | undefined;
            default?: boolean | undefined;
        } & {
            name: string;
        })[];
        noDefaultLabels?: boolean | undefined;
        prereleaseBranches: string[];
        plugins?: (string | [string, any])[] | undefined;
        noVersionPrefix?: boolean | undefined;
        versionBranches?: string | boolean | undefined;
        comment?: {
            delete?: boolean | undefined;
            edit?: boolean | undefined;
        } | undefined;
        changelog?: {
            message?: string | undefined;
        } | undefined;
        release?: {
            prerelease?: boolean | undefined;
        } | undefined;
        shipit?: {
            prerelease?: boolean | undefined;
            noChangelog?: boolean | undefined;
            message?: string | undefined;
            onlyGraduateWithReleaseLabel?: boolean | undefined;
        } | undefined;
        latest?: {
            prerelease?: boolean | undefined;
            noChangelog?: boolean | undefined;
            message?: string | undefined;
        } | undefined;
        canary?: {
            force?: boolean | undefined;
            message?: string | false | undefined;
            target?: "pr-body" | "comment" | "status" | undefined;
        } | undefined;
        next?: {
            force?: boolean | undefined;
            message?: string | undefined;
        } | undefined;
        repo?: string | undefined;
        owner?: string | undefined;
        githubApi?: string | undefined;
        githubGraphqlApi?: string | undefined;
        author?: string | {
            name: string;
            email: string;
        } | undefined;
        name?: string | undefined;
        email?: string | undefined;
        onlyPublishWithReleaseLabel?: boolean | undefined;
        verbose?: boolean | [boolean, boolean] | undefined;
    }>;
    /**
     * Gracefully teardown auto
     */
    teardown(): Promise<void>;
    /** Determine the remote we have auth to push to. */
    private getRemote;
    /** Interactive prompt for initializing an .autorc */
    init(): Promise<void>;
    /** Check if auto is set up correctly */
    info(args: IInfoOptions): Promise<{
        hasError: boolean;
    }>;
    /** Determine if the repo is currently in a prerelease branch */
    inPrereleaseBranch(): boolean;
    /** Determine if the repo is currently in a old-version branch */
    inOldVersionBranch(): boolean;
    /**
     * Create all of the user's labels on the git remote if the don't already exist
     */
    createLabels(options?: ICreateLabelsOptions): Promise<void>;
    /**
     * Get the labels on a specific PR. Defaults to the labels of the last merged PR
     */
    label({ pr, exists }?: ILabelOptions): Promise<void>;
    /**
     * Create a status on a PR.
     */
    prStatus({ dryRun, pr, url, ...options }: IPRStatusOptions): Promise<void>;
    /**
     * Check that a PR has a SEMVER label. Set a success status on the PR.
     */
    prCheck({ dryRun, pr, url, ...options }: IPRCheckOptions): Promise<void>;
    /**
     * Comment on a PR. Only one comment will be present on the PR, Older comments are removed.
     * You can use the "context" option to multiple comments on a PR.
     */
    comment(args: ICommentOptions): Promise<void>;
    /**
     * Update the body of a PR with a message. Only one message will be present in the PR,
     * Older messages are removed. You can use the "context" option to multiple message
     * in a PR body.
     */
    prBody(options: ICommentOptions): Promise<void>;
    /**
     * Calculate the version bump for the current state of the repository.
     */
    version(options?: IVersionOptions): Promise<void>;
    /**
     * Calculate the the changelog and commit it.
     */
    changelog(options?: IChangelogOptions): Promise<void>;
    /**
     * Make a release to the git remote with the changes.
     */
    runRelease(options?: IReleaseOptions): Promise<void>;
    /** Create a canary (or test) version of the project */
    canary(args?: ICanaryOptions): Promise<ShipitInfo | undefined>;
    /**
     * Create a next (or test) version of the project. If on baseBranch will
     * release to the default "next" branch.
     */
    next(args: INextOptions): Promise<ShipitInfo | undefined>;
    /** Force a release to latest and bypass `shipit` safeguards. */
    latest(args?: IShipItOptions): Promise<ShipitInfo | undefined>;
    /**
     * Run the full workflow.
     *
     * 1. Calculate version
     * 2. Make changelog
     * 3. Publish code
     * 4. Create a release
     */
    shipit(args?: IShipItOptions): Promise<void>;
    /** Get the latest version number of the project */
    getCurrentVersion(lastRelease: string): Promise<string>;
    /**
     * A utility function for plugins to check the process for tokens.
     */
    checkEnv(pluginName: string, key: string): void;
    /** Make a release to an old version */
    private oldRelease;
    /** Publish a new version with changelog, publish, and release */
    private publishFullRelease;
    /** Get a pr number from user input or the env */
    private getPrNumber;
    /** Create a client to interact with git */
    private startGit;
    /** Calculate a version from a tag using labels */
    getVersion({ from }?: IVersionOptions): Promise<SEMVER>;
    /** Make a changelog over a range of commits */
    private makeChangelog;
    /** Make a release over a range of commits */
    private makeRelease;
    /** Check if `git status` is clean. */
    readonly checkClean: () => Promise<void>;
    /** Prefix a version with a "v" if needed */
    readonly prefixRelease: (release: string) => string;
    /** Create an auto initialization error */
    private createErrorMessage;
    /** Get the current git user */
    private getGitUser;
    /**
     * Set the git user to make releases and commit with.
     */
    setGitUser(): Promise<void>;
    /** Get the repo to interact with */
    private getRepo;
    /** Find the location of the extended configuration */
    private getExtendedLocation;
    /**
     * Apply all of the plugins in the config.
     */
    private loadPlugins;
    /** Get the branch and build number when in CI environment */
    private getPrEnvInfo;
    /** Get the default for a command from the config */
    private getCommandDefault;
}
export * from "./auto-args";
export { default as InteractiveInit } from "./init";
export { DEFAULT_PRERELEASE_BRANCHES } from "./config";
export { getCurrentBranch } from "./utils/get-current-branch";
export { validatePluginConfiguration } from "./validate-config";
export { ILogger } from "./utils/logger";
export { IPlugin } from "./utils/load-plugins";
export { ICommitAuthor, IExtendedCommit } from "./log-parse";
export { default as Auto } from "./auto";
export { default as SEMVER } from "./semver";
export * from "./semver";
export { default as execPromise } from "./utils/exec-promise";
export { default as getLernaPackages, LernaPackage, } from "./utils/get-lerna-packages";
export { default as inFolder } from "./utils/in-folder";
export { AutoRc } from "./types";
//# sourceMappingURL=auto.d.ts.map