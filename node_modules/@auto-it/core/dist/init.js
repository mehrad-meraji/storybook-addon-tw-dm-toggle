"use strict";
/* eslint-disable no-await-in-loop */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const endent_1 = tslib_1.__importDefault(require("endent"));
const enquirer_1 = require("enquirer");
const make_hooks_1 = require("./utils/make-hooks");
const semver_1 = tslib_1.__importStar(require("./semver"));
const load_plugins_1 = require("./utils/load-plugins");
const fs_1 = require("fs");
/** Get label configuration from the user. */
async function getLabel(label) {
    const response = await enquirer_1.prompt({
        type: "snippet",
        name: "value",
        message: label ? `Edit "${label.name}" label:` : "Add a label:",
        template: label
            ? endent_1.default `{
          name: #{name:${label.name}},
          ${label.changelogTitle
                ? `changelogTitle: #{changelogTitle:${label.changelogTitle}},`
                : ""}
          description: #{description:${label.description}},
          releaseType: #{releaseType:${label.releaseType}}
          color: #{color:${label.color}}
        }`
            : endent_1.default `{
          name: #{name},
          changelogTitle: #{changelogTitle},
          description: #{description},
          releaseType: #{releaseType},
          color: #{color}
        }`,
        /** Check if returned config is valid */
        // @ts-ignore
        validate: (state) => {
            if (!state.values.name) {
                return "name is required for new label";
            }
            const releaseTypes = [
                semver_1.default.major,
                semver_1.default.minor,
                semver_1.default.patch,
                "none",
                "skip",
                "release",
            ];
            if (state.values.releaseType &&
                !releaseTypes.includes(state.values.releaseType)) {
                return `Release type can only be one of the following: ${releaseTypes.join(", ")}`;
            }
            return true;
        },
    });
    return response.value.values;
}
/** Get any custom labels from the user */
async function getAdditionalLabels() {
    const labels = [];
    let addLabels = await enquirer_1.prompt({
        type: "confirm",
        name: "confirmed",
        message: "Would you like to add more labels?",
        initial: "no",
    });
    while (addLabels.confirmed) {
        labels.push(await getLabel());
        addLabels = await enquirer_1.prompt({
            type: "confirm",
            name: "confirmed",
            message: "Would you like to add another label?",
            initial: "no",
        });
    }
    return labels;
}
/** Get default label overrides */
async function getCustomizedDefaultLabels() {
    const labels = [];
    const addLabels = await enquirer_1.prompt({
        type: "confirm",
        name: "confirmed",
        message: "Would you like to customize the default labels?",
        initial: "no",
    });
    if (addLabels.confirmed) {
        await semver_1.defaultLabels.reduce(async (last, defaultLabel) => {
            await last;
            const newLabel = await getLabel(defaultLabel);
            if (JSON.stringify(newLabel) !== JSON.stringify(defaultLabel)) {
                labels.push(Object.assign(Object.assign({}, newLabel), { overwrite: true }));
            }
        }, Promise.resolve());
    }
    return labels;
}
/** Get the plugins the user wants to use */
async function getPlugins() {
    const releasePlugins = {
        Homebrew: "brew",
        "Chrome Web Store": "chrome",
        Cocoapod: "cocoapod",
        "Rust Crate": "crates",
        "Ruby Gem": "gem",
        "Git Tag": "git-tag",
        Gradle: "Gradle",
        Maven: "maven",
        npm: "npm",
    };
    const releasePlugin = await enquirer_1.prompt({
        type: "select",
        name: "value",
        required: true,
        message: "What package manager plugin would you like to publish your project with?",
        choices: Object.keys(releasePlugins),
    });
    const featurePlugin = await enquirer_1.prompt({
        type: "multiselect",
        name: "value",
        required: true,
        message: "What other plugins would you like to use?",
        choices: [
            {
                name: "all-contributors",
                message: "All Contributors - Automatically add contributors as changelogs are produced",
            },
            {
                name: "conventional-commits",
                message: "Conventional Commits - Parse conventional commit messages",
            },
            {
                name: "first-time-contributor",
                message: "First Time Contributor - Thank first time contributors for their work right in your release notes",
            },
            {
                name: "jira",
                message: "Jira - Include Jira story information",
            },
            {
                name: "released",
                message: "Released - Mark PRs as released",
            },
            {
                name: "slack",
                message: "Slack - Post your release notes to a slack channel",
            },
            {
                name: "twitter",
                message: "Twitter - Post tweets after a release is made",
            },
        ],
    });
    return [
        releasePlugins[releasePlugin.value],
        ...featurePlugin.value,
    ];
}
/** Get env vars, create .env file, add to .gitignore */
async function createEnv(hook) {
    let currentEnv;
    try {
        currentEnv = fs_1.readFileSync(".env", { encoding: "utf8" });
    }
    catch (error) {
        currentEnv = "";
    }
    const env = (await hook.promise([])).filter((envVar) => !currentEnv.includes(envVar.variable));
    if (env.length === 0) {
        return;
    }
    const shouldCreateEnv = await enquirer_1.prompt({
        type: "confirm",
        name: "confirmed",
        message: "Would you like to create an .env file? This makes it easy to test and use auto locally.",
        initial: "yes",
    });
    if (!shouldCreateEnv.confirmed) {
        return;
    }
    // Get user input for each variable
    await env.reduce(async (last, envVar) => {
        await last;
        const token = await enquirer_1.prompt({
            type: "input",
            name: "value",
            message: envVar.message,
            required: true,
        });
        currentEnv += `${envVar.variable}=${token.value}\n`;
    }, Promise.resolve());
    fs_1.writeFileSync(".env", currentEnv);
    let gitIgnore;
    try {
        gitIgnore = fs_1.readFileSync(".gitignore", { encoding: "utf8" });
    }
    catch (error) {
        gitIgnore = "";
    }
    // Add env to gitignore if not already there
    if (!gitIgnore.includes(".env")) {
        fs_1.writeFileSync(".gitignore", gitIgnore ? `${gitIgnore}\n.env\n` : `.env\n`);
    }
}
/**
 * Parse the gitlog for commits that are PRs and attach their labels.
 * This class can also be tapped into via plugin to parse commits
 * in other ways (ex: conventional-commits)
 */
class InteractiveInit {
    /** Initialize the the init prompter and tap the default functionality  */
    constructor(options) {
        this.hooks = make_hooks_1.makeInteractiveInitHooks();
        this.logger = options.logger;
    }
    /** Run a prompt to get the author information */
    async getAuthorInformation() {
        const response = await enquirer_1.prompt({
            type: "snippet",
            name: "author",
            message: `What git user would you like to make commits with?`,
            required: true,
            template: endent_1.default `
        Name:   #{name} 
        Email:  #{email}`,
        });
        return response.author.values;
    }
    /** Run a prompt to get the repo information */
    async getRepoInformation() {
        const response = await enquirer_1.prompt({
            type: "snippet",
            name: "repoInfo",
            message: `What GitHub project you would like to publish?`,
            required: true,
            template: endent_1.default `#{owner}/#{repo}`,
        });
        console.log(response);
        return response.repoInfo.values;
    }
    /** Load the default behavior */
    tapDefaults() {
        this.hooks.getRepo.tapPromise("Init Default", this.getRepoInformation);
        this.hooks.getAuthor.tapPromise("Init Default", this.getAuthorInformation);
        this.hooks.createEnv.tap("Init Default", (vars) => [
            ...vars,
            {
                variable: "GH_TOKEN",
                message: `Enter a personal access token for the GitHub API https://github.com/settings/tokens/new`,
            },
        ]);
        this.hooks.writeRcFile.tap("Init Default", (rc) => {
            const filename = ".autorc";
            fs_1.writeFileSync(filename, JSON.stringify(rc, null, 2));
            this.logger.log.success(`Wrote configuration to: ${filename}`);
        });
    }
    /** Run the initialization. */
    async run() {
        let autoRc = {};
        const plugins = await getPlugins();
        if (plugins) {
            plugins
                .map((name) => load_plugins_1.loadPlugin([name, {}], this.logger))
                .forEach((plugin) => {
                if (plugin === null || plugin === void 0 ? void 0 : plugin.init) {
                    plugin.init(this);
                }
            });
            autoRc.plugins = await plugins.reduce(async (last, plugin) => {
                return [
                    ...(await last),
                    (await this.hooks.configurePlugin.promise(plugin)) || plugin,
                ];
            }, Promise.resolve([]));
        }
        this.tapDefaults();
        const repoInfo = await this.hooks.getRepo.promise();
        if (typeof repoInfo === "object") {
            autoRc = Object.assign(Object.assign({}, autoRc), repoInfo);
        }
        const author = await this.hooks.getAuthor.promise();
        if (typeof author === "object") {
            autoRc = Object.assign(Object.assign({}, autoRc), author);
        }
        const onlyPublishWithReleaseLabel = await enquirer_1.prompt({
            type: "confirm",
            name: "confirmed",
            message: 'Only make releases if "release" label is on pull request?',
            initial: "no",
        });
        if (onlyPublishWithReleaseLabel.confirmed) {
            autoRc = Object.assign(Object.assign({}, autoRc), { onlyPublishWithReleaseLabel: true });
        }
        const isEnterprise = await enquirer_1.prompt({
            type: "confirm",
            name: "confirmed",
            message: "Are you using an enterprise instance of GitHub?",
            initial: "no",
        });
        if (isEnterprise.confirmed) {
            const response = await enquirer_1.prompt({
                type: "snippet",
                name: "repoInfo",
                message: `What are the api URLs for your GitHub enterprise instance?`,
                required: true,
                // @ts-ignore
                template: `GitHub API:  #{githubApi}`,
            });
            autoRc = Object.assign(Object.assign({}, autoRc), response.repoInfo.values);
        }
        await createEnv(this.hooks.createEnv);
        const newLabels = [
            ...(await getCustomizedDefaultLabels()),
            ...(await getAdditionalLabels()),
        ];
        if (newLabels.length > 0) {
            autoRc.labels = [...(autoRc.labels || []), ...newLabels];
        }
        await this.hooks.writeRcFile.promise(autoRc);
        this.logger.log.note(endent_1.default `
      Next steps:
      
        - Run "auto create-labels" to create your labels on GitHub
        - Add your environment variables to your CI builds
        - Add "auto shipit" at the end of you build/release process\n
    `);
    }
}
exports.default = InteractiveInit;
//# sourceMappingURL=init.js.map