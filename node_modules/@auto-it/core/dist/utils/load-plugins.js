"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPlugins = exports.loadPlugin = exports.findPlugin = exports.getInstalledPlugins = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
const child_process_1 = require("child_process");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
const path = tslib_1.__importStar(require("path"));
const try_require_1 = tslib_1.__importDefault(require("./try-require"));
const is_binary_1 = tslib_1.__importDefault(require("./is-binary"));
const pluginPatterns = [
    "@auto-it",
    "@auto-canary",
    "auto-plugin-",
    "auto\\/plugins",
].map((p) => new RegExp(`${p}\\/([a-zA-Z-_\\.]+)$`));
const excluded = ["core", "cli", "bot-list"];
/** Format a list of plugins */
const formatPluginList = (plugins) => plugins
    .map((plugin) => {
    if (!pluginPatterns.some((pattern) => plugin.match(pattern))) {
        return undefined;
    }
    const parts = plugin.includes("node_modules/")
        ? plugin.split("node_modules/")
        : plugin.split("auto/plugins/");
    const name = parts[parts.length - 1]
        .replace("@auto-it/", "")
        .replace("@auto-canary/", "");
    if (excluded.includes(name)) {
        return undefined;
    }
    return {
        name,
        path: plugin,
    };
})
    .filter((m) => Boolean(m));
/** Get the paths of available installed plugins. */
const getInstalledPlugins = (global = false) => {
    let modules = [];
    try {
        const stdout = child_process_1.execSync(`npm ls --parseable ${global ? "--global" : ""}`, {
            encoding: "utf8",
            stdio: ["pipe", "pipe", "ignore"],
        });
        modules = stdout.split("\n");
    }
    catch (error) {
        modules = error.stdout.split("\n");
    }
    return formatPluginList(modules);
};
exports.getInstalledPlugins = getInstalledPlugins;
/** Require a plugin and log where it was found. */
function requirePlugin(pluginPath, logger, extendedLocation) {
    const plugin = try_require_1.default(pluginPath, extendedLocation);
    if (plugin) {
        logger.verbose.info(`Found plugin using: ${pluginPath}`);
    }
    return plugin;
}
/** Try to load a plugin in various ways */
function findPlugin(pluginPath, logger, extendedLocation) {
    const isLocal = pluginPath.startsWith(".") ||
        pluginPath.startsWith("/") ||
        pluginPath.match(/^[A-Z]:\\/); // Support for windows paths
    /** Attempt to require a plugin */
    const exists = (p) => Boolean(requirePlugin(p, logger, extendedLocation));
    // Try requiring a path
    if (isLocal && exists(pluginPath)) {
        return pluginPath;
    }
    // Try requiring a path from cwd
    if (isLocal) {
        let localPath = path.join(process.cwd(), pluginPath);
        if (exists(localPath)) {
            return localPath;
        }
        if (extendedLocation) {
            localPath = path.join(extendedLocation.endsWith("package.json")
                ? path.dirname(extendedLocation)
                : extendedLocation, pluginPath);
            if (exists(localPath)) {
                return localPath;
            }
        }
    }
    // For pkg bundle
    const pkgPath = path.join("/snapshot/auto/plugins/", pluginPath, "dist/index.js");
    if (exists(pkgPath)) {
        return pkgPath;
    }
    const userPlugin = `auto-plugin-${pluginPath}`;
    // For a user created plugin
    if (exists(userPlugin)) {
        return userPlugin;
    }
    const canaryPlugin = path.join("@auto-canary", pluginPath);
    // Try importing official plugin
    if (exists(canaryPlugin)) {
        return canaryPlugin;
    }
    const officialPlugin = path.join("@auto-it", pluginPath);
    // Try importing official plugin
    if (exists(officialPlugin)) {
        return officialPlugin;
    }
    // Try requiring a package
    if (pluginPath.includes("/auto-plugin-") ||
        pluginPath.startsWith("auto-plugin-") ||
        pluginPath.startsWith("@auto-it")) {
        if (exists(pluginPath)) {
            return pluginPath;
        }
    }
    logger.log.warn(`Could not find plugin: ${pluginPath}`);
}
exports.findPlugin = findPlugin;
/** Try to load a plugin in various ways */
function loadPlugin([pluginPath, options], logger, extendedLocation) {
    const localPluginPath = findPlugin(pluginPath, logger, extendedLocation);
    if (!localPluginPath) {
        return;
    }
    const plugin = requirePlugin(localPluginPath, logger, extendedLocation);
    if (!plugin) {
        return;
    }
    try {
        if ("default" in plugin && plugin.default) {
            // eslint-disable-next-line new-cap
            return new plugin.default(options);
        }
        return new plugin(options);
    }
    catch (error) {
        logger.log.error(`Plugin at the following path encountered an error: ${pluginPath}`);
        throw error;
    }
}
exports.loadPlugin = loadPlugin;
/** Print a list of plugins */
const printPlugins = (title, modules) => {
    if (!modules.length) {
        return;
    }
    console.log(endent_1.default `
    ${chalk_1.default.underline.white(title)}

    ${modules.map((plugin) => `- ${plugin.name} (${plugin.path})`).join("\n")}
  `);
    console.log("");
};
/** List some of the plugins available to auto */
const listPlugins = async ({ plugins = [] }, logger, extendedLocation) => {
    const rcPlugins = plugins.map((plugin) => {
        const name = typeof plugin === "string" ? plugin : plugin[0];
        const pluginPath = findPlugin(name, logger, extendedLocation) || "";
        return {
            name,
            path: pluginPath.replace("/dist/index.js", ""),
        };
    });
    printPlugins("Found the following plugins in your .autorc:", rcPlugins);
    const bundledPlugins = is_binary_1.default()
        ? formatPluginList(await fast_glob_1.default("/snapshot/auto/plugins/**", {
            onlyDirectories: true,
            deep: 0,
        }))
        : [];
    printPlugins("Found the following plugins bundled with your binary:", bundledPlugins);
    const localPlugins = exports.getInstalledPlugins().map((installed) => (Object.assign(Object.assign({}, installed), { path: path.relative(process.cwd(), installed.path) })));
    printPlugins("Found the following plugins installed in your project:", localPlugins);
    const globalPlugins = exports.getInstalledPlugins(true);
    printPlugins("Found the following plugins globally installed in your environment:", globalPlugins);
    if (!rcPlugins.length &&
        !localPlugins.length &&
        !globalPlugins.length &&
        !bundledPlugins.length) {
        logger.log.note("No plugins found through .autorc, npm, or binary. There might be other plugins available as files on your machine.");
    }
    else {
        logger.log.note('There might be other plugins available as files on your machine. This flag can only list plugins from your .autorc or plugins managed with "npm".');
    }
};
exports.listPlugins = listPlugins;
//# sourceMappingURL=load-plugins.js.map