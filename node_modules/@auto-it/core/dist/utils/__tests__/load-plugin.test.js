"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const child_process_1 = require("child_process");
const load_plugins_1 = require("../load-plugins");
const logger_1 = require("../logger");
const logger = logger_1.dummyLog();
jest.mock("auto-plugin-foo", () => ({
    default: class {
        constructor() {
            this.name = "foo";
        }
    },
}), {
    virtual: true,
});
jest.mock("@my-scope/auto-plugin-bar", () => ({
    default: class {
        constructor() {
            this.name = "bar";
        }
    },
}), { virtual: true });
jest.mock("@auto-it/baz", () => ({
    default: class {
        constructor() {
            this.name = "baz";
        }
    },
}), {
    virtual: true,
});
describe("loadPlugins", () => {
    beforeEach(() => {
        logger_1.setLogLevel("quiet");
    });
    test("should load official plugins", () => {
        var _a, _b;
        expect((_a = load_plugins_1.loadPlugin(["baz", {}], logger)) === null || _a === void 0 ? void 0 : _a.name).toBe("baz");
        expect((_b = load_plugins_1.loadPlugin(["@auto-it/baz", {}], logger)) === null || _b === void 0 ? void 0 : _b.name).toBe("baz");
    });
    test("should load community plugins", () => {
        var _a, _b;
        expect((_a = load_plugins_1.loadPlugin(["foo", {}], logger)) === null || _a === void 0 ? void 0 : _a.name).toBe("foo");
        expect((_b = load_plugins_1.loadPlugin(["auto-plugin-foo", {}], logger)) === null || _b === void 0 ? void 0 : _b.name).toBe("foo");
    });
    test("should load plugin stored relative to extended config package.json", () => {
        var _a;
        expect((_a = load_plugins_1.loadPlugin(["./some-plugin.js", {}], logger, path_1.default.join(__dirname, "../test-config/package.json"))) === null || _a === void 0 ? void 0 : _a.name).toBe("test-1");
    });
    test("should load plugin stored relative to extended config dir", () => {
        var _a;
        expect((_a = load_plugins_1.loadPlugin(["./some-other-plugin.js", {}], logger, path_1.default.join(__dirname, "../test-config"))) === null || _a === void 0 ? void 0 : _a.name).toBe("test-2");
    });
    test("should load scoped plugins", () => {
        var _a;
        expect((_a = load_plugins_1.loadPlugin(["@my-scope/auto-plugin-bar", {}], logger)) === null || _a === void 0 ? void 0 : _a.name).toBe("bar");
    });
    test("should require custom plugins -- fallback to cwd", () => {
        expect(load_plugins_1.loadPlugin([path_1.default.join(__dirname, "./test-plugin.ts"), {}], logger)).toStrictEqual(expect.objectContaining({
            name: "foo",
            config: {},
        }));
    });
    test("should require custom plugins -- surface errors", () => {
        expect(() => load_plugins_1.loadPlugin([path_1.default.join(__dirname, "./test-plugin-malformed.js"), {}], logger)).toThrow();
    });
    test("should load config", () => {
        expect(load_plugins_1.loadPlugin([path_1.default.join(__dirname, "./test-plugin.ts"), "do the thing"], logger)).toStrictEqual(expect.objectContaining({
            name: "foo",
            config: "do the thing",
        }));
    });
});
const exec = jest.fn();
jest.mock("child_process");
// @ts-ignore
child_process_1.execSync.mockImplementation(exec);
describe("getInstalledPlugins", () => {
    test("should find local modules", () => {
        exec.mockReturnValueOnce("/some/folder/node_modules/@auto-it/npm\n/some/folder/node_modules/@auto-it/released");
        expect(load_plugins_1.getInstalledPlugins()).toStrictEqual([
            {
                name: "npm",
                path: "/some/folder/node_modules/@auto-it/npm",
            },
            {
                name: "released",
                path: "/some/folder/node_modules/@auto-it/released",
            },
        ]);
    });
    test("should exclude non plugins", () => {
        exec.mockReturnValueOnce(endent_1.default `
      /some/folder/node_modules/@auto-it/npm
      /some/folder/node_modules/@auto-it/core
      /some/folder/node_modules/autoprefixer
    `);
        expect(load_plugins_1.getInstalledPlugins()).toStrictEqual([
            {
                name: "npm",
                path: "/some/folder/node_modules/@auto-it/npm",
            },
        ]);
    });
    test("should find modules even with errors", () => {
        exec.mockImplementationOnce(() => {
            const error = new Error();
            // @ts-ignore
            error.stdout =
                "/some/folder/node_modules/@auto-it/gradle\n/some/folder/node_modules/@auto-it/chrome";
            throw error;
        });
        expect(load_plugins_1.getInstalledPlugins(true)).toStrictEqual([
            {
                name: "gradle",
                path: "/some/folder/node_modules/@auto-it/gradle",
            },
            {
                name: "chrome",
                path: "/some/folder/node_modules/@auto-it/chrome",
            },
        ]);
    });
});
const log = jest.fn();
console.log = log;
describe("listPlugins", () => {
    beforeEach(() => {
        log.mockClear();
    });
    test("should get plugins from autorc", async () => {
        exec.mockReturnValue("");
        await load_plugins_1.listPlugins({ plugins: ["npm"] }, logger_1.dummyLog());
        expect(log.mock.calls[0]).toMatchSnapshot();
    });
    test("should get plugins from local module", async () => {
        process.cwd = () => "/home";
        exec.mockReturnValue("/some/folder/node_modules/@auto-it/npm\n/some/folder/node_modules/@auto-it/released");
        await load_plugins_1.listPlugins({ plugins: ["npm"] }, logger_1.dummyLog());
        expect(log.mock.calls[0]).toMatchSnapshot();
        expect(log.mock.calls[2]).toMatchSnapshot();
        expect(log.mock.calls[4]).toMatchSnapshot();
    });
});
//# sourceMappingURL=load-plugin.test.js.map