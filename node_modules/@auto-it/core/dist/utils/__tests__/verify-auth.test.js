"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const verify_auth_1 = tslib_1.__importDefault(require("../verify-auth"));
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const spawn = child_process_1.default.spawn;
jest.mock("child_process");
describe("verify-auth", () => {
    test("should handle error", async () => {
        spawn.mockImplementationOnce(() => ({
            stderr: { on: () => { } },
            kill: () => { },
            on: () => {
                throw new Error();
            },
        }));
        expect(await verify_auth_1.default("origin", "main")).toBe(false);
    });
    test("should verify auth when we can push to remote", async () => {
        spawn.mockImplementationOnce(() => ({
            stderr: { on: () => { } },
            kill: () => { },
            on: (_, cb) => cb(),
        }));
        expect(await verify_auth_1.default("origin", "main")).toBe(true);
    });
    test("should not verify auth when we can't push to remote", async () => {
        spawn.mockImplementationOnce(() => ({
            stderr: {
                on: (_, cb) => cb("fatal: could not read Username"),
            },
            kill: () => { },
            on: (_, cb) => cb(),
        }));
        expect(await verify_auth_1.default("bad", "main")).toBe(false);
    });
});
//# sourceMappingURL=verify-auth.test.js.map