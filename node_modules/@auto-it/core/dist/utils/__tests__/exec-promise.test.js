"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const exec_promise_1 = tslib_1.__importDefault(require("../exec-promise"));
const warn = jest.fn();
const error = jest.fn();
jest.mock("../logger.ts", () => () => ({
    // @ts-ignore
    log: { warn: (...args) => warn(...args) },
    // @ts-ignore
    verbose: { error: (...args) => error(...args) },
}));
beforeEach(() => {
    jest.clearAllMocks();
});
test("resolves stdout", async () => {
    expect(await exec_promise_1.default("echo", ["foo"])).toBe("foo");
});
test("filters out anything but strings", async () => {
    expect(await exec_promise_1.default("echo", ["foo", false, undefined, "baz"])).toBe("foo baz");
});
test("fails correctly", async () => {
    expect.assertions(1);
    return expect(exec_promise_1.default("false")).rejects.toMatchInlineSnapshot(`[Error: Running command 'false' with args [] failed]`);
});
test("fails correctly with GH_TOKEN", async () => {
    process.env.GH_TOKEN = "1234567890";
    expect.assertions(1);
    return expect(exec_promise_1.default("false", [process.env.GH_TOKEN])).rejects.toMatchInlineSnapshot(`[Error: Running command 'false' with args [****7890] failed]`);
});
test("appends stdout and stderr", async () => {
    expect.assertions(1);
    return expect(exec_promise_1.default("echo", ["foo", "&&", ">&2", "echo", '"this error"', "&&", "false"])).rejects.toMatchInlineSnapshot(`
            [Error: Running command 'echo' with args [foo, &&, >&2, echo, "this error", &&, false] failed

            foo


            this error
            ]
          `);
});
test("prints stderr when exec exits without a code", async () => {
    jest.spyOn(console, "log").mockImplementation();
    await exec_promise_1.default('>&2 echo "this error"');
    return expect(warn).toHaveBeenCalledWith("this error\n");
});
//# sourceMappingURL=exec-promise.test.js.map