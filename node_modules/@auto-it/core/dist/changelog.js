"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url_1 = require("url");
const url_join_1 = tslib_1.__importDefault(require("url-join"));
const bot_list_1 = tslib_1.__importDefault(require("@auto-it/bot-list"));
const semver_1 = tslib_1.__importDefault(require("./semver"));
const make_hooks_1 = require("./utils/make-hooks");
const get_current_branch_1 = require("./utils/get-current-branch");
const git_1 = require("./git");
/** Determine how deep the markdown headers are in a string */
const getHeaderDepth = (line) => line.split("").reduce((count, char) => (char === "#" ? count + 1 : count), 0);
/** Filter for only commits that have a specific label */
const filterLabel = (commits, label) => commits.filter((commit) => commit.labels.includes(label));
/**
 * Manages creating the "Release Notes" that are included in
 * both the CHANGELOG.md and GitHub releases.
 */
class Changelog {
    /** Initialize the changelog generator with default hooks and labels */
    constructor(logger, options) {
        this.logger = logger;
        this.options = options;
        this.hooks = make_hooks_1.makeChangelogHooks();
        const currentBranch = get_current_branch_1.getCurrentBranch();
        if (!this.options.labels.find((l) => l.name === "pushToBaseBranch")) {
            // Either put the name of a prerelease branch or the base-branch in the changelog
            const branch = (currentBranch &&
                options.prereleaseBranches.includes(currentBranch) &&
                currentBranch) ||
                options.baseBranch;
            this.options.labels = [
                ...this.options.labels,
                {
                    name: "pushToBaseBranch",
                    changelogTitle: `⚠️ Pushed to \`${branch}\``,
                    description: "N/A",
                    releaseType: semver_1.default.patch,
                },
            ];
        }
    }
    /** Load the default configuration */
    loadDefaultHooks() {
        this.hooks.renderChangelogAuthor.tap("Default", (author, commit) => this.createUserLink(author, commit));
        this.hooks.renderChangelogAuthorLine.tap("Default", (author, user) => {
            const authorString = author.name && user ? `${author.name} (${user})` : user;
            return authorString ? `- ${authorString}` : undefined;
        });
        this.hooks.renderChangelogLine.tap("Default", (line) => line);
        this.hooks.renderChangelogTitle.tap("Default", (label, changelogTitles) => `#### ${changelogTitles[label]}\n`);
        this.hooks.omitReleaseNotes.tap("Bots", (commit) => {
            if (commit.authors.some((author) => (author.name && bot_list_1.default.includes(author.name)) ||
                (author.username && bot_list_1.default.includes(author.username)))) {
                return true;
            }
        });
    }
    /** Generate the release notes for a group of commits */
    async generateReleaseNotes(commits) {
        if (commits.length === 0) {
            return "";
        }
        this.logger.verbose.info("Generating release notes for:\n", commits);
        const split = this.splitCommits(commits);
        this.logger.verbose.info("Split commits into groups");
        this.logger.veryVerbose.info("\n", split);
        const sections = [];
        const extraNotes = (await this.hooks.addToBody.promise([], commits)) || [];
        extraNotes.filter(Boolean).forEach((note) => sections.push(note));
        await this.createReleaseNotesSection(commits, sections);
        this.logger.verbose.info("Added release notes to changelog");
        this.authors = this.getAllAuthors(split);
        await this.createLabelSection(split, sections);
        this.logger.verbose.info("Added groups to changelog");
        await this.createAuthorSection(sections);
        this.logger.verbose.info("Added authors to changelog");
        const result = sections.join("\n\n");
        this.logger.verbose.info("Successfully generated release notes.");
        return result;
    }
    /** Create a link to a user for use in the changelog */
    createUserLink(author, commit) {
        const githubUrl = new url_1.URL(this.options.baseUrl).origin;
        if (author.username === "invalid-email-address") {
            return;
        }
        return author.username
            ? `[@${author.username}](${url_join_1.default(githubUrl, author.username)})`
            : author.email || commit.authorEmail;
    }
    /** Split commits into changelogTitle sections. */
    splitCommits(commits) {
        var _a, _b;
        let currentCommits = [...commits];
        const order = ["major", "minor", "patch"];
        const sections = this.options.labels
            .filter((label) => label.changelogTitle)
            .sort((a, b) => {
            const bIndex = order.indexOf(b.releaseType || "") + 1 || order.length + 1;
            const aIndex = order.indexOf(a.releaseType || "") + 1 || order.length + 1;
            if (aIndex === bIndex) {
                // If the labels are the same release type order by user defined order
                return (this.options.labels.findIndex((l) => l.name === a.name) -
                    this.options.labels.findIndex((l) => l.name === b.name));
            }
            return aIndex - bIndex;
        })
            .reduce((acc, item) => [...acc, item], []);
        const defaultPatchLabelName = ((_a = this.options.labels.find((l) => l.default)) === null || _a === void 0 ? void 0 : _a.name) ||
            ((_b = this.options.labels.find((l) => l.releaseType === "patch")) === null || _b === void 0 ? void 0 : _b.name) ||
            "patch";
        commits
            .filter(({ labels }) => 
        // in case pr commit doesn't contain a label for section inclusion
        !sections.some((section) => labels.includes(section.name)) ||
            // in this case we auto attached a patch when it was merged
            (labels[0] === "released" && labels.length === 1))
            .map(({ labels }) => labels.push(defaultPatchLabelName));
        return Object.assign({}, ...sections.map((label) => {
            const matchedCommits = filterLabel(currentCommits, label.name);
            currentCommits = currentCommits.filter((commit) => !matchedCommits.includes(commit));
            return matchedCommits.length === 0
                ? {}
                : { [label.name]: matchedCommits };
        }));
    }
    /** Create a list of users */
    async createUserLinkList(commit) {
        const result = new Set();
        await Promise.all(commit.authors.map(async (rawAuthor) => {
            const data = this.authors.find(([, commitAuthor]) => (commitAuthor.name &&
                rawAuthor.name &&
                commitAuthor.name === rawAuthor.name) ||
                (commitAuthor.email &&
                    rawAuthor.email &&
                    commitAuthor.email === rawAuthor.email) ||
                (commitAuthor.username &&
                    rawAuthor.username &&
                    commitAuthor.username === rawAuthor.username)) || [{}, rawAuthor];
            const link = await this.hooks.renderChangelogAuthor.promise(data[1], commit, this.options);
            if (link) {
                result.add(link);
            }
        }));
        return [...result].join(" ");
    }
    /** Generate a link to a PR or issues */
    generateIssueLink(commit) {
        var _a;
        if ((_a = commit.pullRequest) === null || _a === void 0 ? void 0 : _a.number) {
            const prLink = url_join_1.default(this.options.baseUrl, "pull", commit.pullRequest.number.toString());
            return `[#${commit.pullRequest.number}](${prLink})`;
        }
    }
    /** Transform a commit into a line in the changelog */
    async generateCommitNote(commit) {
        const subject = commit.subject
            ? commit.subject
                .split("\n")[0]
                .trim()
                .replace("[skip ci]", "\\[skip ci\\]")
            : "";
        const pr = this.generateIssueLink(commit);
        const user = await this.createUserLinkList(commit);
        return `- ${subject}${pr ? ` ${pr}` : ""}${user ? ` (${user})` : ""}`;
    }
    /** Get all the authors in the provided commits */
    getAllAuthors(split) {
        const commits = Object.values(split).reduce((labeledCommits, sectionCommits) => [...labeledCommits, ...sectionCommits], []);
        return commits
            .map((commit) => commit.authors
            .filter((author) => author.username !== "invalid-email-address" &&
            (author.name || author.email || author.username))
            .map((author) => [commit, author]))
            .reduce((all, more) => [...all, ...more], [])
            .sort((a) => ("id" in a[1] ? 0 : 1));
    }
    /** Create a section in the changelog to showcase contributing authors */
    async createAuthorSection(sections) {
        const authors = new Set();
        const authorsWithFullData = this.authors.map(([, author]) => author).filter((author) => "id" in author);
        await Promise.all(this.authors.map(async ([commit, author]) => {
            const info = authorsWithFullData.find((u) => (author.name && u.name === author.name) ||
                (author.email && u.email === author.email)) || author;
            const user = await this.hooks.renderChangelogAuthor.promise(info, commit, this.options);
            const authorEntry = await this.hooks.renderChangelogAuthorLine.promise(info, user);
            if (authorEntry && !authors.has(authorEntry)) {
                authors.add(authorEntry);
            }
        }));
        if (authors.size === 0) {
            return;
        }
        let authorSection = `#### Authors: ${authors.size}\n\n`;
        authorSection += [...authors].sort((a, b) => a.localeCompare(b)).join("\n");
        sections.push(authorSection);
    }
    /** Create a section in the changelog to with all of the changelog notes organized by change type */
    async createLabelSection(split, sections) {
        const changelogTitles = this.options.labels.reduce((titles, label) => {
            if (label.changelogTitle) {
                titles[label.name] = label.changelogTitle;
            }
            return titles;
        }, {});
        const labelSections = await Promise.all(Object.entries(split).map(async ([label, labelCommits]) => {
            const title = await this.hooks.renderChangelogTitle.promise(label, changelogTitles);
            const lines = new Set();
            await Promise.all(labelCommits.map(async (commit) => {
                var _a;
                const base = ((_a = commit.pullRequest) === null || _a === void 0 ? void 0 : _a.base) || "";
                const branch = base.includes("/") ? base.split("/")[1] : base;
                // We want to keep the release notes for a prerelease branch but
                // omit the changelog item
                if (branch && this.options.prereleaseBranches.includes(branch)) {
                    return true;
                }
                const line = await this.hooks.renderChangelogLine.promise(await this.generateCommitNote(commit), commit);
                lines.add(line);
            }));
            const sortedLines = await this.hooks.sortChangelogLines.promise([...lines].sort((a, b) => a.split("\n").length - b.split("\n").length));
            return [title || "", sortedLines];
        }));
        const mergedSections = labelSections.reduce((acc, [title, commits]) => (Object.assign(Object.assign({}, acc), { [title]: [...(acc[title] || []), ...commits] })), {});
        Object.entries(mergedSections)
            .map(([title, lines]) => [title, ...lines].join("\n"))
            .map((section) => sections.push(section));
    }
    /** Gather extra release notes to display at the top of the changelog */
    async createReleaseNotesSection(commits, sections) {
        if (!commits.length) {
            return;
        }
        let section = "";
        const visited = new Set();
        await Promise.all(commits.map(async (commit) => {
            if (await this.hooks.omitReleaseNotes.promise(commit)) {
                return;
            }
            const pr = commit.pullRequest;
            if (!pr || !pr.body) {
                return;
            }
            const title = /^[#]{0,5}[ ]*[R|r]elease [N|n]otes$/;
            const lines = pr.body
                .split("\n")
                .map((line) => line.replace(/\r$/, ""));
            const notesStart = lines.findIndex((line) => Boolean(line.match(title)));
            if (notesStart === -1 || visited.has(pr.number)) {
                return;
            }
            const depth = getHeaderDepth(lines[notesStart]);
            visited.add(pr.number);
            let notes = "";
            for (let index = notesStart; index < lines.length; index++) {
                const line = lines[index];
                const isTitle = line.match(title);
                if ((line.startsWith("#") &&
                    getHeaderDepth(line) <= depth &&
                    !isTitle) ||
                    line.startsWith(git_1.automatedCommentIdentifier)) {
                    break;
                }
                if (!isTitle) {
                    notes += `${line}\n`;
                }
            }
            section += `#### ${commit.subject.trim()} (${this.generateIssueLink(commit)})\n\n${notes.trim()}\n\n`;
        }));
        if (!section) {
            return;
        }
        sections.push(`### Release Notes\n\n${section}---`);
    }
}
exports.default = Changelog;
//# sourceMappingURL=changelog.js.map