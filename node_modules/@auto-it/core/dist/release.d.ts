import { AsyncSeriesBailHook, SyncHook } from "tapable";
import { ICreateLabelsOptions } from "./auto-args";
import Changelog from "./changelog";
import Git from "./git";
import LogParse, { IExtendedCommit } from "./log-parse";
import SEMVER, { IVersionLabels, ILabelDefinition } from "./semver";
import { ILogger } from "./utils/logger";
import { LoadedAutoRc } from "./types";
/** Construct a map of label => semver label */
export declare const getVersionMap: (labels?: ({
    changelogTitle?: string | undefined;
    color?: string | undefined;
    description?: string | undefined;
    releaseType?: import("./semver").VersionLabel | "none" | undefined;
    overwrite?: boolean | undefined;
    default?: boolean | undefined;
} & {
    name: string;
})[]) => IVersionLabels;
export interface IReleaseHooks {
    /** This is where you hook into the changelog's hooks. This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks` */
    onCreateChangelog: SyncHook<[Changelog, SEMVER | undefined]>;
    /** Control the titles in the `CHANGELOG.md` */
    createChangelogTitle: AsyncSeriesBailHook<[], string | void>;
    /** This is where you hook into the LogParse's hooks. This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks` */
    onCreateLogParse: SyncHook<[LogParse]>;
}
/**
 * A class for interacting with the git remote
 */
export default class Release {
    /** Plugin entry points */
    readonly hooks: IReleaseHooks;
    /** Options Release was initialized with */
    readonly config: LoadedAutoRc;
    /** A class that handles interacting with git and GitHub */
    private readonly git;
    /** A logger that uses log levels */
    private readonly logger;
    /** The version bump being used during "shipit" */
    private readonly versionLabels;
    /** Initialize the release manager */
    constructor(git: Git, config: LoadedAutoRc, logger?: ILogger);
    /** Make the class that will generate changelogs for the project */
    makeChangelog(version?: SEMVER): Promise<Changelog>;
    /**
     * Generate a changelog from a range of commits.
     *
     * @param from - sha or tag to start changelog from
     * @param to - sha or tag to end changelog at (defaults to HEAD)
     */
    generateReleaseNotes(from: string, to?: string, version?: SEMVER): Promise<string>;
    /** Get all the commits that will be included in a release */
    getCommitsInRelease(from: string, to?: string): Promise<IExtendedCommit[]>;
    /** Update a changelog with a new set of release notes */
    updateChangelogFile(title: string, releaseNotes: string, changelogPath: string): Promise<void>;
    /**
     * Prepend a set of release notes to the changelog.md
     *
     * @param releaseNotes - Release notes to prepend to the changelog
     * @param lastRelease - Last release version of the code. Could be the first commit SHA
     * @param currentVersion - Current version of the code
     */
    addToChangelog(releaseNotes: string, lastRelease: string, currentVersion: string): Promise<void>;
    /**
     * Get a range of commits. The commits will have PR numbers and labels attached
     *
     * @param from - Tag or SHA to start at
     * @param to - Tag or SHA to end at (defaults to HEAD)
     */
    getCommits(from: string, to?: string): Promise<IExtendedCommit[]>;
    /** Go through the configured labels and either add them to the project or update them */
    addLabelsToProject(labels: ILabelDefinition[], options?: ICreateLabelsOptions): Promise<void>;
    /**
     * Calculate the SEMVER bump over a range of commits using the PR labels
     *
     * @param from - Tag or SHA to start at
     * @param to - Tag or SHA to end at (defaults to HEAD)
     */
    getSemverBump(from: string, to?: string): Promise<SEMVER>;
    /** Given a tag get the next incremented version */
    calcNextVersion(lastTag: string): Promise<string | null>;
    /** Create the class that will parse the log for PR info */
    private createLogParse;
    /** Get a the PRs that have been merged since the last GitHub release. */
    private getPRsSinceLastRelease;
    /**
     * Add the PR info (labels and body) to the commit
     *
     * @param commit - Commit to modify
     */
    private addPrInfoToCommit;
    /**
     * Commits from rebased PRs do not have messages that tie them to a PR
     * Instead we have to find all PRs since the last release and try to match
     * their merge commit SHAs.
     */
    private getPRForRebasedCommits;
    /** Parse the commit for information about the author and any other author that might have helped. */
    private attachAuthor;
}
//# sourceMappingURL=release.d.ts.map