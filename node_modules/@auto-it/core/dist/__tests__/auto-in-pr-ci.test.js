"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = require("../auto");
const semver_1 = tslib_1.__importDefault(require("../semver"));
const logger_1 = require("../utils/logger");
const make_commit_from_msg_1 = tslib_1.__importDefault(require("./make-commit-from-msg"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const exec_promise_1 = tslib_1.__importDefault(require("../utils/exec-promise"));
const exec = jest.fn();
jest.mock("../utils/exec-promise");
// @ts-ignore
exec_promise_1.default.mockImplementation(exec);
exec.mockResolvedValue("");
jest.mock("env-ci", () => () => ({
    pr: 123,
    build: 1,
    isCi: true,
    isPr: true,
    branch: "ci-test",
}));
const defaults = {
    owner: "foo",
    repo: "bar",
};
process.env.GH_TOKEN = "XXX";
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.repos = {
                    get: jest.fn().mockReturnValue({}),
                };
                this.issues = {
                    createComment: jest.fn().mockReturnValue({ data: [] }),
                    listComments: jest.fn().mockReturnValue({ data: [] }),
                    listLabelsOnIssue: jest.fn().mockReturnValue({ data: [] }),
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
describe("canary in ci", () => {
    test("calls the canary hook with the canary version", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const canary = jest.fn();
        auto.hooks.canary.tap("test", canary);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        await auto.canary();
        expect(canary).toHaveBeenCalledWith(expect.objectContaining({
            bump: semver_1.default.patch,
            canaryIdentifier: "-canary.123.1",
        }));
    });
    test("add to pr-body on PR in CI", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        auto.hooks.canary.tap("test", () => "1.2.4-canary.123.1");
        const version = await auto.canary({ pr: 123, build: 1 });
        expect(addToPrBody).toHaveBeenCalled();
        expect(version.newVersion).toBe("1.2.4-canary.123.1");
    });
    test("adds comment on PR in CI", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        const comment = jest.fn();
        auto.comment = comment;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        auto.hooks.canary.tap("test", () => "1.2.4-canary.123.1");
        const version = await auto.canary({ pr: 123, build: 1, target: "comment" });
        expect(addToPrBody).not.toHaveBeenCalled();
        expect(comment).toHaveBeenCalled();
        expect(version.newVersion).toBe("1.2.4-canary.123.1");
    });
    test("adds status on PR in CI", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        const prStatus = jest.fn();
        auto.prStatus = prStatus;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        auto.hooks.canary.tap("test", () => "1.2.4-canary.123.1");
        const version = await auto.canary({ pr: 123, build: 1, target: "status" });
        expect(addToPrBody).not.toHaveBeenCalled();
        expect(prStatus).toHaveBeenCalled();
        expect(version.newVersion).toBe("1.2.4-canary.123.1");
    });
    test("should fail when canaries not implemented", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        // @ts-ignore
        jest.spyOn(process, "exit").mockImplementationOnce(() => { });
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        await auto.canary({ pr: 123, build: 1, message: "false" });
        expect(process.exit).toHaveBeenCalled();
    });
    test('should not comment when passed "false"', async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        auto.hooks.canary.tap("test", ({ canaryIdentifier }) => `1.2.4-${canaryIdentifier}`);
        await auto.canary({ pr: 123, build: 1, message: "false" });
        expect(addToPrBody).not.toHaveBeenCalled();
    });
    test("can override pr and build", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const addToPrBody = jest.fn();
        auto.git.addToPrBody = addToPrBody;
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        auto.hooks.canary.tap("test", ({ canaryIdentifier }) => `1.2.4-${canaryIdentifier}`);
        const version = await auto.canary({ pr: 456, build: 5 });
        expect(version.newVersion).toBe("1.2.4--canary.456.5");
    });
});
describe("shipit in ci", () => {
    test("should publish canary in PR", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        jest.spyOn(auto.git, "addToPrBody").mockImplementation();
        auto.release.getCommitsInRelease = () => Promise.resolve([]);
        auto.release.getCommits = () => Promise.resolve([]);
        const canary = jest.fn();
        auto.hooks.canary.tap("test", canary);
        await auto.shipit();
        expect(canary).toHaveBeenCalledWith(expect.objectContaining({
            bump: semver_1.default.patch,
            canaryIdentifier: "-canary.123.1",
        }));
    });
});
describe("next in ci", () => {
    test("should post comment with new version", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        // @ts-ignore
        jest.spyOn(console, "log").mockImplementation();
        exec.mockResolvedValue("v1.0.0");
        // @ts-ignore
        auto.checkClean = () => Promise.resolve(true);
        const prBody = jest.fn();
        // @ts-ignore
        auto.prBody = prBody;
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        auto.git.publish = () => Promise.resolve({ data: {} });
        auto.git.getLatestTagInBranch = () => Promise.resolve("1.2.3");
        auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
        auto.release.generateReleaseNotes = () => Promise.resolve("notes");
        auto.release.getCommitsInRelease = () => Promise.resolve([make_commit_from_msg_1.default("Test Commit")]);
        const afterRelease = jest.fn();
        auto.hooks.afterRelease.tap("test", afterRelease);
        auto.hooks.next.tap("test", () => ["1.2.4-next.0"]);
        jest.spyOn(auto.release, "getCommits").mockImplementation();
        await auto.next({});
        expect(prBody).toHaveBeenCalledWith({
            context: "prerelease-version",
            pr: 123,
            message: endent_1.default `
        # Version

        Published prerelease version: \`1.2.4-next.0\`

        <details>
          <summary>Changelog</summary>

          notes
        </details>
      `,
        });
    });
    test("should use labels on next branch PR", async () => {
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        // @ts-ignore
        auto.inPrereleaseBranch = () => true;
        // @ts-ignore
        jest.spyOn(console, "log").mockImplementation();
        auto.git.getLatestTagInBranch = () => Promise.resolve("1.4.0-next.0");
        auto.release.getSemverBump = () => Promise.resolve(semver_1.default.patch);
        auto.git.getLabels = () => Promise.resolve([]);
        expect(await auto.getVersion()).toBe(semver_1.default.prepatch);
        auto.git.getLabels = () => Promise.resolve([semver_1.default.major]);
        expect(await auto.getVersion()).toBe(semver_1.default.premajor);
    });
});
//# sourceMappingURL=auto-in-pr-ci.test.js.map