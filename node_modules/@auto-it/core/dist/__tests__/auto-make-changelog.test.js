"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = require("../auto");
const logger_1 = require("../utils/logger");
const child_process_1 = tslib_1.__importDefault(require("child_process"));
jest
    .spyOn(child_process_1.default, "execSync")
    .mockImplementation()
    // @ts-ignore
    .mockReturnValue("");
const importMock = jest.fn();
jest.mock("import-cwd", () => (path) => importMock(path));
jest.mock("env-ci", () => () => ({ isCi: false, branch: "main" }));
jest.mock("../utils/exec-promise", () => () => Promise.resolve(""));
const defaults = {
    owner: "foo",
    repo: "bar",
};
process.env.GH_TOKEN = "XXXX";
const search = jest.fn();
jest.mock("cosmiconfig", () => ({
    cosmiconfig: () => ({
        search,
    }),
}));
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.search = {
                    issuesAndPullRequests: () => ({ data: { items: [] } }),
                };
                this.repos = {
                    get: jest.fn().mockReturnValue(Promise.resolve({})),
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
// @ts-ignore
jest.mock("gitlog", () => ({
    gitlogPromise: () => Promise.resolve([
        {
            rawBody: "foo",
        },
        {
            rawBody: "foo",
        },
    ]),
}));
describe("Auto", () => {
    test("should add to changelog", async () => {
        const auto = new auto_1.Auto(Object.assign({ plugins: [] }, defaults));
        auto.logger = logger_1.dummyLog();
        await auto.loadConfig();
        const addToChangelog = jest.fn();
        auto.release.addToChangelog = addToChangelog;
        jest.spyOn(auto.release, "generateReleaseNotes").mockImplementation();
        jest.spyOn(auto.release, "getCommitsInRelease").mockImplementation();
        await auto.changelog({ from: "v1.0.0" });
        expect(addToChangelog).toHaveBeenCalled();
    });
});
//# sourceMappingURL=auto-make-changelog.test.js.map