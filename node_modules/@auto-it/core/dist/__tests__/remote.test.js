"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const auto_1 = require("../auto");
const logger_1 = require("../utils/logger");
const defaultRemote = "git@github.foo.com";
const defaults = {
    owner: "foo",
    repo: "bar",
};
process.env.GH_TOKEN = "XXXX";
const reposGet = jest.fn();
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.repos = {
                    get: reposGet,
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
const execSpy = jest.fn();
// @ts-ignore
jest.mock("../utils/exec-promise.ts", () => (...args) => execSpy(...args));
describe("remote parsing", () => {
    test("should fall back to origin when no git", async () => {
        const auto = new auto_1.Auto(defaults);
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve());
        // @ts-ignore
        expect(await auto.getRemote()).toBe("origin");
    });
    test("should fall back to configured remote when no git", async () => {
        const auto = new auto_1.Auto(defaults);
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve(defaultRemote));
        // @ts-ignore
        expect(await auto.getRemote()).toBe(defaultRemote);
    });
    test("should fall back to configured remote", async () => {
        const auto = new auto_1.Auto(defaults);
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve(defaultRemote));
        auto.git = {
            getProject: () => { },
            verifyAuth: () => false,
        };
        // @ts-ignore
        expect(await auto.getRemote()).toBe(defaultRemote);
    });
    test("use html_url when authed", async () => {
        const html_url = "https://my.repo";
        const auto = new auto_1.Auto(defaults);
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve(defaultRemote));
        auto.git = {
            getProject: () => ({ html_url }),
            verifyAuth: (url) => url === html_url,
        };
        // @ts-ignore
        expect(await auto.getRemote()).toBe(html_url);
    });
    test("use fall back to default when not authed", async () => {
        const html_url = "https://my.repo";
        const auto = new auto_1.Auto(defaults);
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve(defaultRemote));
        auto.git = {
            getProject: () => ({ html_url }),
            verifyAuth: () => false,
        };
        // @ts-ignore
        expect(await auto.getRemote()).toBe(defaultRemote);
    });
    test("add token to url if html doesn't auth", async () => {
        const html_url = "https://my.repo";
        const auto = new auto_1.Auto(defaults);
        const token = process.env.GITHUB_TOKEN;
        process.env.GITHUB_TOKEN = "";
        process.env.GH_TOKEN = "XXXX";
        auto.logger = logger_1.dummyLog();
        execSpy.mockReturnValue(Promise.resolve(defaultRemote));
        auto.git = {
            getProject: () => ({ html_url }),
            verifyAuth: (url) => url !== html_url,
        };
        // @ts-ignore
        expect(await auto.getRemote()).toBe("https://XXXX@my.repo/");
        process.env.GITHUB_TOKEN = token;
    });
});
//# sourceMappingURL=remote.test.js.map