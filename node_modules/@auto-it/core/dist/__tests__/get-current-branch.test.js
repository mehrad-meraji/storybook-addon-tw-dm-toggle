"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const auto_1 = require("../auto");
jest.mock('child_process');
describe('getCurrentBranch', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    describe('when isPr', () => {
        it('returns pr branch from env ci when valid', () => {
            const env = {
                isPr: true,
                prBranch: 'my-pr-branch'
            };
            expect(auto_1.getCurrentBranch(env)).toBe('my-pr-branch');
        });
        it('tries git command when PR is invalid', () => {
            const env = {
                isPr: true,
                prBranch: 'undefined'
            };
            auto_1.getCurrentBranch(env);
            expect(child_process_1.execSync).toHaveBeenCalledWith("git symbolic-ref --short HEAD", {
                encoding: "utf8",
                stdio: "ignore",
            });
        });
    });
    describe('when not isPr', () => {
        it('returns pr branch from env ci when valid', () => {
            const env = {
                isPr: false,
                prBranch: 'my-pr-branch',
                branch: 'my-release-branch'
            };
            expect(auto_1.getCurrentBranch(env)).toBe('my-release-branch');
            expect(child_process_1.execSync).not.toHaveBeenCalled();
        });
        it('tries git command when branch name is invalid', () => {
            const env = {
                isPr: false,
                prBranch: 'my-pr-branch',
                branch: undefined
            };
            auto_1.getCurrentBranch(env);
            expect(child_process_1.execSync).toHaveBeenCalledWith("git symbolic-ref --short HEAD", {
                encoding: "utf8",
                stdio: "ignore",
            });
        });
    });
});
//# sourceMappingURL=get-current-branch.test.js.map