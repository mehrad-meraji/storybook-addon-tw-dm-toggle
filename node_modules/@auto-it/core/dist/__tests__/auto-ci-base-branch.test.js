"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const logger_1 = require("../utils/logger");
jest.mock("env-ci");
const envSpy = env_ci_1.default;
envSpy.mockImplementation(() => ({
    isCi: true,
    branch: "main",
}));
const auto_1 = require("../auto");
const defaults = {
    baseBranch: "main",
    owner: "foo",
    repo: "bar",
};
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.search = {
                    issuesAndPullRequests: () => ({ data: { items: [] } }),
                };
                this.repos = {
                    get: jest.fn().mockReturnValue({}),
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
describe("Auto", () => {
    describe("pr-check", () => {
        jest.setTimeout(10 * 1000);
        let createStatus;
        beforeEach(() => {
            createStatus = jest.fn();
        });
        const required = {
            url: "https://google.com",
        };
        test("should exit successfully if ran from main + CI", async () => {
            const auto = new auto_1.Auto(defaults);
            const exit = jest.fn();
            envSpy.mockImplementationOnce(() => ({
                isCi: true,
                branch: "main",
            }));
            // @ts-ignore
            process.exit = exit;
            auto.logger = logger_1.dummyLog();
            await auto.loadConfig();
            auto.git.createStatus = createStatus;
            await auto.prCheck(Object.assign({}, required));
            expect(exit).toHaveBeenCalledWith(0);
        });
    });
});
//# sourceMappingURL=auto-ci-base-branch.test.js.map