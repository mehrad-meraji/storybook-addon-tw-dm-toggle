"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = require("../auto");
const semver_1 = tslib_1.__importDefault(require("../semver"));
const logger_1 = require("../utils/logger");
jest.mock("env-ci", () => () => ({
    branch: "local-test",
}));
const defaults = {
    owner: "foo",
    repo: "bar",
};
const listLabelsOnIssue = jest.fn();
process.env.GH_TOKEN = "XXXX";
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.repos = {
                    get: jest.fn().mockReturnValue({}),
                };
                this.issues = {
                    listLabelsOnIssue: listLabelsOnIssue.mockReturnValue({ data: [] }),
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
test("shipit should publish canary in locally when not on baseBranch", async () => {
    const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
    auto.logger = logger_1.dummyLog();
    // @ts-ignore
    auto.checkClean = () => Promise.resolve(true);
    await auto.loadConfig();
    auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
    auto.git.getSha = () => Promise.resolve("abcdefghijklmnop");
    jest.spyOn(auto.git, "createComment").mockImplementation();
    auto.release.getCommitsInRelease = () => Promise.resolve([]);
    auto.release.getCommits = () => Promise.resolve([]);
    const canary = jest.fn();
    auto.hooks.canary.tap("test", canary);
    await auto.shipit();
    expect(canary).toHaveBeenCalledWith(expect.objectContaining({
        bump: semver_1.default.patch,
        canaryIdentifier: "-canary.abcdefg",
    }));
});
test("canary should use PR labels correctly", async () => {
    const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { onlyPublishWithReleaseLabel: true, plugins: [] }));
    auto.logger = logger_1.dummyLog();
    // @ts-ignore
    auto.checkClean = () => Promise.resolve(true);
    await auto.loadConfig();
    auto.git.getLatestRelease = () => Promise.resolve("1.2.3");
    auto.git.getSha = () => Promise.resolve("abcdefghijklmnop");
    jest.spyOn(auto.git, "createComment").mockImplementation();
    auto.release.getCommitsInRelease = () => Promise.resolve([]);
    auto.release.getCommits = () => Promise.resolve([]);
    const canary = jest.fn();
    auto.hooks.canary.tap("test", canary);
    listLabelsOnIssue.mockReturnValueOnce({
        data: [{ name: "internal" }, { name: "release" }],
    });
    await auto.canary({ pr: 123 });
    expect(canary).toHaveBeenCalled();
});
//# sourceMappingURL=auto-canary-local.test.js.map