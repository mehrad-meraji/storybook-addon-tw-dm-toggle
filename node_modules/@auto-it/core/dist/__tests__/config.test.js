"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = tslib_1.__importStar(require("../config"));
const logger_1 = require("../utils/logger");
const semver_1 = tslib_1.__importDefault(require("../semver"));
const fetchSpy = jest.fn();
// @ts-ignore
jest.mock("node-fetch", () => (...args) => fetchSpy(...args));
beforeEach(() => {
    fetchSpy.mockClear();
});
const log = logger_1.dummyLog();
const importMock = jest.fn();
jest.mock("import-cwd", () => {
    return (path) => importMock(path);
});
describe("normalizeLabel", () => {
    test("should extend base label", () => {
        const label = {
            name: "foo",
            releaseType: semver_1.default.major,
        };
        expect(config_1.normalizeLabel(label)).toStrictEqual({
            description: "Increment the major version when merged",
            color: "#C5000B",
            name: "foo",
            changelogTitle: "ðŸ’¥ Breaking Change",
            releaseType: semver_1.default.major,
        });
    });
});
describe("normalizeLabels", () => {
    test("user labels should override defaults", () => {
        expect(config_1.normalizeLabels({}).find((l) => l.name === "minor")).toStrictEqual({
            description: "Increment the minor version when merged",
            color: "#F1A60E",
            name: "minor",
            changelogTitle: "ðŸš€ Enhancement",
            releaseType: semver_1.default.minor,
        });
        expect(config_1.normalizeLabels({ labels: [{ name: "foo", releaseType: "minor" }] }).find((l) => l.name === "foo")).toStrictEqual({
            description: "Increment the minor version when merged",
            color: "#F1A60E",
            name: "foo",
            changelogTitle: "ðŸš€ Enhancement",
            releaseType: semver_1.default.minor,
        });
    });
});
describe("loadExtendConfig", () => {
    test("should reject when no config found", async () => {
        const config = new config_1.default(log);
        await expect(config.loadExtendConfig("nothing")).rejects.toBeInstanceOf(Error);
    });
    test("should load file path", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "../fake/path.json" ? { someOption: "url" } : undefined);
        expect(await config.loadExtendConfig("../fake/path.json")).toStrictEqual({
            someOption: "url",
        });
    });
    test("should load package.json file from path", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "./package.json" ? { auto: { someOption: "url" } } : undefined);
        expect(await config.loadExtendConfig("./package.json")).toStrictEqual({
            someOption: "url",
        });
    });
    test("should fail if file path points to js file", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "../fake/path.js" ? { someOption: "url" } : undefined);
        await expect(config.loadExtendConfig("../fake/path.js")).rejects.toBeInstanceOf(Error);
    });
    test("should call fetch on URL with config", async () => {
        const config = new config_1.default(log);
        const mockFetchJson = jest.fn();
        mockFetchJson.mockReturnValue({});
        fetchSpy.mockResolvedValueOnce({
            json: mockFetchJson,
        });
        await config.loadExtendConfig("http://www.test.com/config.json");
        expect(fetchSpy).toHaveBeenCalled();
        expect(mockFetchJson).toHaveBeenCalled();
    });
    test("should reject if extends URL fails to fetch", async () => {
        const config = new config_1.default(log);
        fetchSpy.mockRejectedValueOnce(new Error());
        await expect(config.loadExtendConfig("http://www.test.com/config.json")).rejects.toBeInstanceOf(Error);
    });
    test("should load @NAME/auto-config", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "@artsy/auto-config/package.json"
            ? { auto: { onlyPublishWithReleaseLabel: true } }
            : undefined);
        expect(await config.loadExtendConfig("@artsy")).toStrictEqual({
            extends: "@artsy/auto-config/package.json",
            onlyPublishWithReleaseLabel: true,
        });
    });
    test("should load auto-config-NAME", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "auto-config-fuego/package.json"
            ? { auto: { noVersionPrefix: true } }
            : undefined);
        expect(await config.loadExtendConfig("fuego")).toStrictEqual({
            extends: "auto-config-fuego/package.json",
            noVersionPrefix: true,
        });
    });
    test("should load an npm module", async () => {
        const config = new config_1.default(log);
        importMock.mockImplementation((path) => path === "auto-config-from-module"
            ? { noVersionPrefix: true }
            : undefined);
        expect(await config.loadExtendConfig("auto-config-from-module")).toStrictEqual({
            extends: "auto-config-from-module",
            noVersionPrefix: true,
        });
    });
});
//# sourceMappingURL=config.test.js.map