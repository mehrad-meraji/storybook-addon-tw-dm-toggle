"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = require("../auto");
const logger_1 = require("../utils/logger");
const make_commit_from_msg_1 = tslib_1.__importDefault(require("./make-commit-from-msg"));
const exec_promise_1 = tslib_1.__importDefault(require("../utils/exec-promise"));
const exec = jest.fn();
jest.mock("../utils/exec-promise");
// @ts-ignore
exec_promise_1.default.mockImplementation(exec);
exec.mockResolvedValue("");
jest.mock("../utils/git-reset.ts");
jest.mock("../utils/load-plugins.ts");
jest.mock("env-ci", () => () => ({ isCi: false, branch: "next" }));
const defaults = {
    baseBranch: "main",
    owner: "foo",
    repo: "bar",
};
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.search = {
                    issuesAndPullRequests: () => ({ data: { items: [] } }),
                };
                this.repos = {
                    get: jest.fn().mockReturnValue({}),
                };
                this.hook = {
                    error: () => undefined,
                };
                this.issues = {
                    listLabelsOnIssue: jest.fn().mockReturnValue({ data: [] }),
                };
                this.users = {
                    getAuthenticated: jest.fn().mockResolvedValue({}),
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
// @ts-ignore
jest.mock("gitlog", () => ({
    gitlogPromise: () => Promise.resolve([
        {
            rawBody: "foo",
            hash: "123",
        },
        {
            rawBody: "foo",
            hash: "456",
        },
    ]),
}));
test("falls back to local baseBranch if it doesn't exist on origin", async () => {
    const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
    // @ts-ignore
    auto.checkClean = () => Promise.resolve(true);
    auto.logger = logger_1.dummyLog();
    await auto.loadConfig();
    auto.remote = "origin";
    auto.git.publish = () => Promise.resolve({ data: {} });
    auto.git.getLastTagNotInBaseBranch = () => Promise.reject(new Error("Test"));
    auto.git.getLatestTagInBranch = () => Promise.reject(new Error("Test"));
    auto.git.getLatestRelease = () => Promise.resolve("abcd");
    auto.release.generateReleaseNotes = () => Promise.resolve("notes");
    auto.release.getCommitsInRelease = () => Promise.resolve([
        make_commit_from_msg_1.default("Test Commit", { labels: ["skip-release"] }),
    ]);
    jest.spyOn(auto.release, "getCommits").mockImplementation();
    const next = jest.fn();
    auto.hooks.next.tap("test", next);
    await auto.next({});
    expect(exec).toHaveBeenCalledWith("git", [
        "rev-list",
        "--boundary",
        "next...origin/main",
        "--left-only",
    ]);
    auto.git.shaExists = () => Promise.resolve(false);
    await auto.next({});
    expect(exec).toHaveBeenCalledWith("git", [
        "rev-list",
        "--boundary",
        "next...main",
        "--left-only",
    ]);
});
//# sourceMappingURL=next.test.js.map