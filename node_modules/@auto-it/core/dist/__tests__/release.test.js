"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const git_1 = tslib_1.__importDefault(require("../git"));
const log_parse_1 = tslib_1.__importDefault(require("../log-parse"));
const release_1 = tslib_1.__importStar(require("../release"));
const semver_1 = tslib_1.__importStar(require("../semver"));
const logger_1 = require("../utils/logger");
const make_commit_from_msg_1 = tslib_1.__importDefault(require("./make-commit-from-msg"));
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const get_current_branch_1 = require("../utils/get-current-branch");
const config_1 = require("../config");
const { execSync } = child_process_1.default;
const exec = jest.fn();
child_process_1.default.execSync = exec.mockReturnValue("");
afterAll(() => {
    child_process_1.default.execSync = execSync;
});
const constructor = jest.fn();
const getGitLog = jest.fn();
const graphql = jest.fn();
const getUserByEmail = jest.fn();
const getPr = jest.fn().mockReturnValue(Promise.resolve());
const getPullRequest = jest.fn();
const getLatestRelease = jest.fn();
const getSha = jest.fn();
const getCommit = jest
    .fn()
    .mockReturnValue(Promise.resolve({ data: { author: { login: "" } } }));
const createStatus = jest.fn();
const getProject = jest.fn();
const createComment = jest.fn();
const changedPackages = jest.fn();
const getCommitsForPR = jest.fn().mockReturnValue(Promise.resolve(undefined));
const getUserByUsername = jest.fn();
const getProjectLabels = jest.fn();
const createLabel = jest.fn();
const updateLabel = jest.fn();
const getPullRequests = jest.fn();
const getLatestReleaseInfo = jest.fn();
const searchRepo = jest.fn();
const getCommitDate = jest.fn();
const getFirstCommit = jest.fn();
getProject.mockResolvedValue({
    html_url: "https://github.com/web/site",
});
const mockLabels = (labels) => ({
    data: { labels: labels.map((label) => ({ name: label })), user: {} },
});
// @ts-ignore
jest.mock("../git.ts", () => class MockGit {
    constructor(...args) {
        this.options = { owner: "test", repo: "test", version: "1.0.0" };
        this.graphql = graphql;
        this.getGitLog = getGitLog;
        this.getPr = getPr;
        this.getLatestRelease = getLatestRelease;
        this.getPullRequest = getPullRequest;
        this.getSha = getSha;
        this.createStatus = createStatus;
        this.createComment = createComment;
        this.getProject = getProject;
        this.changedPackages = changedPackages;
        this.getCommitsForPR = getCommitsForPR;
        this.getUserByUsername = getUserByUsername;
        this.getProjectLabels = getProjectLabels;
        this.createLabel = createLabel;
        this.updateLabel = updateLabel;
        this.getPullRequests = getPullRequests;
        this.getLatestReleaseInfo = getLatestReleaseInfo;
        this.searchRepo = searchRepo;
        this.getCommitDate = getCommitDate;
        this.getFirstCommit = getFirstCommit;
        this.getCommit = getCommit;
        this.getUserByEmail = getUserByEmail;
        constructor(...args);
    }
});
getGitLog.mockReturnValue([]);
const execSpy = jest.fn();
// @ts-ignore
jest.mock("../utils/exec-promise.ts", () => (...args) => execSpy(...args));
const currentBranch = jest.fn();
currentBranch.mockReturnValue("main");
jest.mock("../utils/get-current-branch.ts");
// @ts-ignore
get_current_branch_1.getCurrentBranch.mockImplementation(currentBranch);
const existsSync = jest.fn();
const writeSpy = jest.fn();
let readResult = "{}";
const config = {
    baseBranch: "main",
    prereleaseBranches: config_1.DEFAULT_PRERELEASE_BRANCHES,
    labels: semver_1.defaultLabels,
};
jest.mock("fs", () => ({
    // @ts-ignore
    existsSync: (...args) => existsSync(...args),
    // @ts-ignore
    readFile: (a, b, cb) => {
        cb(undefined, readResult);
    },
    ReadStream: function () { },
    WriteStream: function () { },
    // @ts-ignore
    closeSync: () => undefined,
    // @ts-ignore
    writeFile: (file, data, cb) => {
        cb(undefined, writeSpy(file, data));
    },
    // @ts-ignore
    read: (a, b, cb) => {
        cb(undefined);
    },
}));
const logParse = new log_parse_1.default();
const git = new git_1.default({
    owner: "Andrew",
    repo: "test",
    token: "MY_TOKEN",
    baseBranch: "main",
});
describe("getVersionMap", () => {
    test("should return the default map", () => {
        expect(release_1.getVersionMap()).toStrictEqual(new Map([
            ["major", ["major"]],
            ["minor", ["minor"]],
            ["patch", ["patch", "performance"]],
            ["skip", ["skip-release"]],
            ["release", ["release"]],
            ["none", ["internal", "documentation", "tests", "dependencies"]],
        ]));
    });
    test("should add custom labels", () => {
        expect(release_1.getVersionMap([
            { name: "major", releaseType: semver_1.default.major },
            { name: "BREAKING", releaseType: semver_1.default.major },
        ])).toStrictEqual(new Map([["major", ["major", "BREAKING"]]]));
    });
});
describe("Release", () => {
    beforeEach(() => {
        jest.clearAllMocks();
        getUserByUsername.mockReset();
    });
    describe("getCommits", () => {
        test("should default to HEAD", async () => {
            const gh = new release_1.default(git, config);
            await gh.getCommits("12345");
            expect(getGitLog).toHaveBeenCalled();
        });
        test("should use configured HEAD", async () => {
            const gh = new release_1.default(git, config);
            await gh.getCommits("12345", "1234");
            expect(getGitLog).toHaveBeenCalled();
        });
        test("should not resolve authors with no PR commits", async () => {
            const commits = [
                make_commit_from_msg_1.default("First"),
                make_commit_from_msg_1.default("Second"),
                make_commit_from_msg_1.default("Third"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            const gh = new release_1.default(git, config);
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should resolve authors with PR commits", async () => {
            const commits = await logParse.normalizeCommits([
                make_commit_from_msg_1.default("First"),
                make_commit_from_msg_1.default("Second (#123)", {
                    name: "Andrew Lisowski",
                    email: "andrew@users.noreply.github.com",
                }),
                make_commit_from_msg_1.default("Second (#123)", {
                    name: "Andrew Lisowski",
                    email: "lisowski54@gmail.com",
                }),
                make_commit_from_msg_1.default("Third"),
            ]);
            getGitLog.mockReturnValueOnce(commits);
            getCommitsForPR.mockReturnValueOnce(Promise.resolve([
                {
                    author: {
                        login: "andrew",
                    },
                },
            ]));
            getCommit.mockReturnValueOnce(Promise.resolve({ data: { author: { login: "adam" } } }));
            getUserByUsername.mockImplementation((username) => {
                if (username === "andrew") {
                    return {
                        login: "andrew",
                        name: "Andrew Lisowski",
                    };
                }
                return {
                    login: "adam",
                    name: "Adam Dierkens",
                };
            });
            const gh = new release_1.default(git, config);
            const modifiedCommits = await gh.getCommits("12345", "1234");
            expect(getUserByUsername).toHaveBeenCalled();
            expect(modifiedCommits).toMatchSnapshot();
        });
        test("should be able to omit by username", async () => {
            const commits = await logParse.normalizeCommits([
                make_commit_from_msg_1.default("First"),
                make_commit_from_msg_1.default("Second (#123)", {
                    name: "Andrew Lisowski",
                    email: "lisowski54@gmail.com",
                }),
                make_commit_from_msg_1.default("Third"),
            ]);
            getGitLog.mockReturnValueOnce(commits);
            getCommitsForPR.mockReturnValueOnce(Promise.resolve([
                {
                    author: {
                        login: "andrew",
                    },
                },
            ]));
            getCommit.mockReturnValueOnce(Promise.resolve({ data: { author: { login: "adam" } } }));
            getCommit.mockReturnValueOnce(Promise.resolve({ data: { author: { login: "adam" } } }));
            getUserByUsername.mockImplementation((username) => {
                if (username === "andrew") {
                    return {
                        login: "andrew",
                        name: "Andrew Lisowski",
                    };
                }
                return {
                    login: "adam",
                    name: "Adam Dierkens",
                };
            });
            const gh = new release_1.default(git, config);
            gh.hooks.onCreateLogParse.tap("test", (parser) => {
                parser.hooks.omitCommit.tap("test", (commit) => Boolean(commit.authors.find((author) => author.username === "adam")));
            });
            const modifiedCommits = await gh.getCommits("12345", "1234");
            expect(modifiedCommits).toMatchSnapshot();
        });
        test("should ignore rebased commits if no last release", async () => {
            const gh = new release_1.default(git, config);
            getLatestReleaseInfo.mockReturnValueOnce({});
            const commits = await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Second (#123)"),
            ]);
            getGitLog.mockReturnValueOnce(commits);
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should match rebased commits to PRs", async () => {
            const gh = new release_1.default(git, config);
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Feature (#124)"),
                make_commit_from_msg_1.default("I was rebased", {
                    hash: "1a2b",
                }),
            ]));
            getUserByUsername.mockImplementationOnce(() => {
                return {
                    login: "adam",
                    name: "Adam Dierkens",
                };
            });
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should match rebased commits to PRs with first commit", async () => {
            const gh = new release_1.default(git, config);
            getLatestReleaseInfo.mockImplementationOnce(() => {
                throw new Error("no releases yet");
            });
            getCommitDate.mockReturnValueOnce("2019-01-16");
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Feature (#124)"),
                make_commit_from_msg_1.default("I was rebased", {
                    hash: "1a2b",
                }),
            ]));
            getUserByUsername.mockImplementationOnce(() => {
                return {
                    login: "adam",
                    name: "Adam Dierkens",
                };
            });
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should omit commits that have already been released", async () => {
            const gh = new release_1.default(git, config);
            jest.spyOn(console, "log").mockImplementationOnce(() => { });
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Feature (#124)"),
                make_commit_from_msg_1.default("I was released previously", {
                    hash: "1a2b",
                }),
            ]));
            exec.mockReturnValueOnce("0");
            exec.mockImplementationOnce(() => {
                throw new Error();
            });
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should not omit commits in next branch", async () => {
            const gh = new release_1.default(git, config);
            jest.spyOn(console, "log").mockImplementationOnce(() => { });
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Feature (#124)"),
                make_commit_from_msg_1.default("I wasn't released previously", {
                    hash: "1a2b",
                }),
            ]));
            exec.mockReturnValueOnce("0");
            exec.mockImplementationOnce(() => {
                throw new Error();
            });
            exec.mockImplementationOnce(() => {
                throw new Error();
            });
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should include PR opener in authors (in case of external rebase)", async () => {
            const gh = new release_1.default(git, config);
            const info = {
                data: {
                    number: 124,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                    user: { login: "renovate" },
                },
            };
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            searchRepo.mockReturnValueOnce({ items: [{ number: 124 }] });
            getPullRequest.mockReturnValueOnce(info);
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([make_commit_from_msg_1.default("Feature (#124)")]));
            getPr.mockReturnValueOnce(Promise.resolve(info));
            getUserByUsername.mockReturnValueOnce({
                name: "Renovate",
                email: "renovate@automation.com",
                login: "renovate",
            });
            exec.mockReturnValueOnce("1");
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
        test("should use latest title of PR", async () => {
            const gh = new release_1.default(git, config);
            const info = {
                data: {
                    number: 124,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                    user: { login: "renovate" },
                    title: "Updated Title",
                },
            };
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            searchRepo.mockReturnValueOnce({ items: [{ number: 124 }] });
            getPullRequest.mockReturnValueOnce(info);
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([make_commit_from_msg_1.default("Feature (#124)")]));
            getPr.mockReturnValueOnce(Promise.resolve(info));
            getUserByUsername.mockImplementationOnce(() => {
                return {
                    login: "adam",
                    name: "Adam Dierkens",
                };
            });
            exec.mockReturnValueOnce("1");
            expect(await gh.getCommits("12345", "1234")).toMatchSnapshot();
        });
    });
    describe("addToChangelog", () => {
        test("creates new changelog if one didn't exist - from 0", async () => {
            const gh = new release_1.default(git, config);
            await gh.addToChangelog("# My new Notes", "klajsdlfk4lj51l43k5hj234l", "v0.0.0");
            expect(writeSpy.mock.calls[0][1].includes(`# My new Notes`)).toBe(true);
        });
        test("creates new changelog if one didn't exist", async () => {
            const gh = new release_1.default(git, config);
            await gh.addToChangelog("# My new Notes", "v1.0.0", "v1.0.0");
            expect(writeSpy.mock.calls[0][1].includes(`v1.0.1`)).toBe(true);
        });
        test("creates changelog with v in versions", async () => {
            const gh = new release_1.default(git, {
                noVersionPrefix: true,
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            await gh.addToChangelog("# My new Notes", "1.0.0", "1.0.0");
            expect(writeSpy.mock.calls[0][1].includes(`1.0.1`)).toBe(true);
        });
        test("prepends to old changelog", async () => {
            const gh = new release_1.default(git, config);
            existsSync.mockReturnValueOnce(true);
            readResult = "# My old Notes";
            await gh.addToChangelog("# My new Notes", "asdfasdlkfjlkj435l2j", "v0.0.0");
            expect(writeSpy.mock.calls[0][1].includes(readResult)).toBe(true);
        });
    });
    describe("generateReleaseNotes", () => {
        test("should default to HEAD", async () => {
            const gh = new release_1.default(git, config);
            expect(await gh.generateReleaseNotes("1234")).toBe("");
        });
        test("should use configured HEAD", async () => {
            const gh = new release_1.default(git, config);
            expect(await gh.generateReleaseNotes("1234", "123")).toBe("");
        });
        test("should include PR-less commits", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                {
                    hash: "1",
                    authorName: "Adam Dierkens",
                    authorEmail: "adam@dierkens.com",
                    authors: [
                        {
                            name: "Adam Dierkens",
                            email: "adam@dierkens.com",
                        },
                    ],
                    subject: "I should be included\nBut this should not.",
                },
                {
                    hash: "2",
                    authorName: "Adam Dierkens",
                    authorEmail: "adam@dierkens.com",
                    authors: [
                        {
                            name: "Adam Dierkens",
                            email: "adam@dierkens.com",
                        },
                    ],
                    subject: "First Feature",
                    pullRequest: {
                        number: "1235",
                    },
                },
                {
                    hash: "3",
                    authorName: "Adam Dierkens",
                    authorEmail: "adam@dierkens.com",
                    authors: [
                        {
                            name: "Adam Dierkens",
                            email: "adam@dierkens.com",
                        },
                    ],
                    subject: "Random Commit for pr 1235",
                },
            ];
            getGitLog.mockReturnValueOnce(commits);
            getCommitsForPR.mockReturnValueOnce(Promise.resolve(undefined));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            getCommitsForPR.mockReturnValueOnce(Promise.resolve([{ sha: "3" }]));
            graphql.mockReturnValueOnce({
                hash_1: { edges: [] },
            });
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should get extra user data for login", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                {
                    hash: "1",
                    authors: [],
                    subject: "I have a login attached",
                    pullRequest: {
                        number: "1235",
                    },
                },
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve({
                data: { labels: [], user: { login: "adierkens" } },
            }));
            getUserByUsername.mockReturnValueOnce({
                login: "adierkens",
                name: "Adam Dierkens",
            });
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should allow user to configure section headings", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
                make_commit_from_msg_1.default("Fourth (#1237)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["major"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["documentation", "internal"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["patch"])));
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should match rebased commits to PRs", async () => {
            const gh = new release_1.default(git, config);
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            getCommitsForPR.mockReturnValueOnce(Promise.resolve(undefined));
            // Rebased PR will have different commit SHAs than the commits in base branch
            getCommitsForPR.mockReturnValueOnce(Promise.resolve([{ sha: "1a1a" }]));
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce([
                make_commit_from_msg_1.default("Feature (#124)"),
                make_commit_from_msg_1.default("I was rebased\n\n", {
                    hash: "1a2b",
                }),
                {
                    hash: "1",
                    authorName: "Adam Dierkens",
                    authorEmail: "adam@dierkens.com",
                    subject: "I am a commit to main",
                },
            ]);
            graphql.mockReturnValueOnce({
                hash_1: { edges: [] },
            });
            expect(await gh.generateReleaseNotes("12345", "1234")).toMatchSnapshot();
        });
        test("should match commits with related PRs", async () => {
            const gh = new release_1.default(git, config);
            getLatestReleaseInfo.mockReturnValueOnce({
                published_at: "2019-01-16",
            });
            getCommitsForPR.mockReturnValueOnce(Promise.resolve(undefined));
            // Rebased PR will have different commit SHAs than the commits in base branch
            getCommitsForPR.mockReturnValueOnce(Promise.resolve([{ sha: "1a1a" }]));
            searchRepo.mockReturnValueOnce({ items: [{ number: 123 }] });
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            getPullRequest.mockReturnValueOnce({
                data: {
                    number: 123,
                    merge_commit_sha: "1a2b",
                    labels: [{ name: "skip-release" }, { name: "minor" }],
                },
            });
            getGitLog.mockReturnValueOnce(await logParse.normalizeCommits([
                make_commit_from_msg_1.default("Feature (#124)"),
                {
                    hash: "1",
                    files: [],
                    authorName: "Adam Dierkens",
                    authorEmail: "adam@dierkens.com",
                    subject: "I am a commit with a related PR",
                },
            ]));
            searchRepo.mockReturnValueOnce({
                total_count: 1,
                items: [{ labels: [{ name: "patch" }] }],
            });
            expect(await gh.generateReleaseNotes("12345", "1234")).toMatchSnapshot();
        });
        test("should find matching PRs for shas through search", async () => {
            const gh = new release_1.default(git, config);
            getGitLog.mockReturnValueOnce([
                make_commit_from_msg_1.default("Doom Patrol enabled", {
                    hash: "1",
                }),
                make_commit_from_msg_1.default("Autobots roll out!", {
                    hash: "2",
                }),
            ]);
            graphql.mockReturnValueOnce({
                hash_1: {
                    edges: [
                        {
                            node: {
                                state: "MERGED",
                                labels: { edges: [{ node: { name: "major" } }] },
                            },
                        },
                    ],
                },
                // PR with no label, should become patch
                hash_2: {
                    edges: [{ node: { state: "MERGED", labels: undefined } }],
                },
            });
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should ignore closed prs", async () => {
            const gh = new release_1.default(git, config);
            getGitLog.mockReturnValueOnce([
                make_commit_from_msg_1.default("Doom Patrol enabled", {
                    hash: "1",
                }),
                make_commit_from_msg_1.default("Autobots roll out!", {
                    hash: "2",
                }),
            ]);
            graphql.mockReturnValueOnce({
                hash_1: {
                    edges: [
                        {
                            node: {
                                labels: {
                                    edges: [{ node: { name: "major" } }],
                                },
                                state: "CLOSED",
                            },
                        },
                    ],
                },
                // PR with no label, should become patch
                hash_2: {
                    edges: [{ node: { labels: undefined, state: "MERGED" } }],
                },
            });
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should detect pre-release branches", async () => {
            const gh = new release_1.default(git, config);
            getGitLog.mockReturnValueOnce([
                make_commit_from_msg_1.default("Doom Patrol enabled", {
                    hash: "1",
                }),
                make_commit_from_msg_1.default("Autobots roll out!", {
                    hash: "2",
                }),
            ]);
            currentBranch.mockReturnValue("next");
            graphql.mockReturnValueOnce({
                hash_1: {
                    edges: [
                        {
                            node: {
                                labels: {
                                    edges: [{ node: { name: "major" } }],
                                },
                                state: "CLOSED",
                                headRefName: "next",
                                headRepositoryOwner: {
                                    login: "test",
                                },
                            },
                        },
                    ],
                },
                // PR with no label, should become patch
                hash_2: {
                    edges: [{ node: { labels: undefined, state: "MERGED" } }],
                },
            });
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should include PRs merged to other PRs", async () => {
            const gh = new release_1.default(git, config);
            getGitLog.mockReturnValueOnce([
                make_commit_from_msg_1.default("Doom (#12343)", {
                    hash: "1",
                }),
                make_commit_from_msg_1.default("Dino (#1235)", {
                    hash: "2",
                }),
                make_commit_from_msg_1.default("Foo Bar", {
                    hash: "3",
                }),
            ]);
            getCommitsForPR.mockReturnValue(Promise.resolve([
                {
                    sha: "2",
                    commit: {},
                    author: {
                        name: "Adam Dierkens",
                        email: "adam@dierkens.com",
                    },
                },
            ]));
            getCommitsForPR.mockReturnValue(Promise.resolve([
                {
                    sha: "2",
                    commit: {},
                    author: {
                        name: "Adam Dierkens",
                        email: "adam@dierkens.com",
                    },
                },
            ]));
            getCommitsForPR.mockReturnValue(Promise.resolve([
                {
                    sha: "3",
                    commit: {},
                    author: {
                        name: "Adam Dierkens",
                        email: "adam@dierkens.com",
                    },
                },
            ]));
            getCommitsForPR.mockReturnValue(Promise.resolve([
                {
                    sha: "3",
                    commit: {},
                    author: {
                        name: "Adam Dierkens",
                        email: "adam@dierkens.com",
                    },
                },
            ]));
            expect(await gh.generateReleaseNotes("1234", "123")).toMatchSnapshot();
        });
        test("should gracefully handle failed fetches to merged PRs", async () => {
            const gh = new release_1.default(git, config);
            const commits = await logParse.normalizeCommits([
                make_commit_from_msg_1.default("First"),
                make_commit_from_msg_1.default("Second (#123)"),
            ]);
            getGitLog.mockReturnValueOnce(commits);
            getCommitsForPR
                .mockReturnValueOnce(Promise.reject(new Error("bah")))
                .mockReturnValueOnce(Promise.reject(new Error("bah")));
            await expect(gh.generateReleaseNotes("1234", "123")).resolves.toBeDefined();
        });
    });
    describe("getSemverBump", () => {
        test("default to patch", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First"),
                make_commit_from_msg_1.default("Second"),
                make_commit_from_msg_1.default("Third"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            expect(await gh.getSemverBump("1234")).toBe(semver_1.default.patch);
        });
        test("should use higher version", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second"),
                make_commit_from_msg_1.default("Third"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            expect(await gh.getSemverBump("1234", "123")).toBe(semver_1.default.minor);
        });
        test("should not publish a release", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release", "patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release", "patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release", "minor"])));
            expect(await gh.getSemverBump("1234", "123")).toBe("");
        });
        test("should publish a release", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release", "patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release", "minor"])));
            expect(await gh.getSemverBump("1234", "123")).toBe(semver_1.default.minor);
        });
        test("should default to publish a prepatch", async () => {
            const gh = new release_1.default(git, config);
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["skip-release"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels([])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels([])));
            expect(await gh.getSemverBump("1234", "123")).toBe("");
        });
        test("should not publish a release in onlyPublishWithReleaseLabel without label", async () => {
            const gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["major"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["patch"])));
            expect(await gh.getSemverBump("1234", "123")).toBe("");
        });
        test("should publish a release in onlyPublishWithReleaseLabel with label", async () => {
            const gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["release", "patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["minor"])));
            expect(await gh.getSemverBump("1234", "123")).toBe(semver_1.default.minor);
        });
        test("should be able to configure labels - no release", async () => {
            const customLabels = [
                ...semver_1.defaultLabels,
                { name: "Version: Major", releaseType: semver_1.default.major },
                { name: "Version: Minor", releaseType: semver_1.default.minor },
                { name: "Version: Patch", releaseType: semver_1.default.patch },
                { name: "Deploy", releaseType: "release" },
            ];
            const gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: customLabels,
                baseBranch: "main",
            });
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            // Test default labels do nothing
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Major"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Patch"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Minor", "release"])));
            expect(await gh.getSemverBump("1234", "123")).toBe("");
        });
        test("should be able to configure labels", async () => {
            const customLabels = [
                ...semver_1.defaultLabels,
                { name: "Version: Major", releaseType: semver_1.default.major },
                { name: "Version: Minor", releaseType: semver_1.default.minor },
                { name: "Version: Patch", releaseType: semver_1.default.patch },
                { name: "Deploy", releaseType: "release" },
            ];
            const gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: customLabels,
                baseBranch: "main",
            });
            const commits = [
                make_commit_from_msg_1.default("First (#1234)"),
                make_commit_from_msg_1.default("Second (#1235)"),
                make_commit_from_msg_1.default("Third (#1236)"),
            ];
            // Test deploy label creates release
            getGitLog.mockReturnValueOnce(commits);
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Minor", "Deploy"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Major"])));
            getPr.mockReturnValueOnce(Promise.resolve(mockLabels(["Version: Patch"])));
            expect(await gh.getSemverBump("1234", "123")).toBe(semver_1.default.major);
        });
    });
    describe("addLabelsToProject", () => {
        test("should add labels", async () => {
            const gh = new release_1.default(git, config);
            const customLabels = [
                { name: "1", description: "major", releaseType: semver_1.default.major },
                { name: "2", description: "minor", releaseType: semver_1.default.minor },
                { name: "3", description: "patch", releaseType: semver_1.default.patch },
            ];
            await gh.addLabelsToProject(customLabels);
            expect(createLabel).toHaveBeenCalledWith({
                name: "1",
                description: "major",
                releaseType: semver_1.default.major,
            });
            expect(createLabel).toHaveBeenCalledWith({
                name: "2",
                description: "minor",
                releaseType: semver_1.default.minor,
            });
            expect(createLabel).toHaveBeenCalledWith({
                name: "3",
                description: "patch",
                releaseType: semver_1.default.patch,
            });
        });
        test("should log that it has created the labels", async () => {
            const mockLogger = logger_1.dummyLog();
            jest.spyOn(mockLogger.log, "log").mockImplementation();
            const gh = new release_1.default(git, {
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            }, mockLogger);
            const labels = [
                { name: "3", description: "three", releaseType: semver_1.default.patch },
            ];
            await gh.addLabelsToProject(labels);
            expect(mockLogger.log.log).toHaveBeenCalledWith("Created labels: 3");
            expect(mockLogger.log.log).toHaveBeenCalledWith("\nYou can see these, and more at https://github.com/web/site/labels");
        });
        test("should not add old labels", async () => {
            const gh = new release_1.default(git, config);
            const labels = [
                { name: "1", description: "major", releaseType: semver_1.default.major },
                { name: "2", description: "minor", releaseType: semver_1.default.minor },
            ];
            getProjectLabels.mockReturnValueOnce(["1"]);
            await gh.addLabelsToProject(labels);
            expect(updateLabel).toHaveBeenCalledWith({
                name: "1",
                description: "major",
                releaseType: semver_1.default.major,
            });
            expect(createLabel).toHaveBeenCalledWith({
                description: "minor",
                name: "2",
                releaseType: semver_1.default.minor,
            });
        });
        test("should not add old labels - case sensitive", async () => {
            const gh = new release_1.default(git, config);
            const labels = [
                { name: "major", description: "", releaseType: semver_1.default.major },
                { name: "Minor", description: "", releaseType: semver_1.default.minor },
            ];
            getProjectLabels.mockReturnValueOnce(["Major", "minor"]);
            await gh.addLabelsToProject(labels);
            expect(updateLabel).toHaveBeenCalledWith({
                name: "major",
                description: "",
                releaseType: semver_1.default.major,
            });
            expect(updateLabel).toHaveBeenCalledWith({
                description: "",
                name: "Minor",
                releaseType: semver_1.default.minor,
            });
        });
        test("should add release label in onlyPublishWithReleaseLabel mode", async () => {
            let gh = new release_1.default(git, {
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            const labels = [
                {
                    name: "deploy",
                    description: "release the code",
                    releaseType: "release",
                },
            ];
            await gh.addLabelsToProject(labels);
            expect(createLabel).not.toHaveBeenCalledWith({
                name: "deploy",
                description: "release the code",
                releaseType: "release",
            });
            gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            await gh.addLabelsToProject(labels);
            expect(createLabel).toHaveBeenCalledWith({
                name: "deploy",
                description: "release the code",
                releaseType: "release",
            });
        });
        test("should add skip-release label not in onlyPublishWithReleaseLabel mode", async () => {
            let gh = new release_1.default(git, {
                onlyPublishWithReleaseLabel: true,
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            const labels = [
                {
                    name: "no!",
                    description: "Do not create a release",
                    releaseType: "skip",
                },
            ];
            await gh.addLabelsToProject(labels);
            expect(createLabel).not.toHaveBeenCalledWith({
                name: "no!",
                description: "Do not create a release",
                releaseType: "skip",
            });
            gh = new release_1.default(git, {
                prereleaseBranches: ["next"],
                labels: semver_1.defaultLabels,
                baseBranch: "main",
            });
            await gh.addLabelsToProject(labels);
            expect(createLabel).toHaveBeenCalledWith({
                description: "Do not create a release",
                name: "no!",
                releaseType: "skip",
            });
        });
    });
});
//# sourceMappingURL=release.test.js.map