"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const auto_1 = require("../auto");
const semver_1 = tslib_1.__importDefault(require("../semver"));
const exec_promise_1 = tslib_1.__importDefault(require("../utils/exec-promise"));
const execSpy = exec_promise_1.default;
jest.mock("../utils/exec-promise");
const search = jest.fn();
jest.mock("cosmiconfig", () => ({
    cosmiconfig: () => ({
        search,
    }),
}));
jest.mock("@octokit/rest", () => {
    var _a;
    const Octokit = (_a = class MockOctokit {
            constructor() {
                this.authenticate = () => undefined;
                this.search = {
                    issuesAndPullRequests: () => ({ data: { items: [] } }),
                };
                this.repos = {
                    get: jest.fn().mockReturnValueOnce({}),
                };
                this.hook = {
                    error: () => undefined,
                };
            }
        },
        _a.plugin = () => Octokit,
        _a);
    return { Octokit };
});
const defaults = {
    owner: "foo",
    repo: "bar",
};
describe("Old Version Branches", () => {
    beforeEach(() => {
        search.mockClear();
        execSpy.mockClear();
    });
    test("should not create old version branches", async () => {
        search.mockReturnValueOnce({});
        execSpy.mockResolvedValueOnce(undefined);
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        await auto.loadConfig();
        auto.hooks.getPreviousVersion.tap("test", () => "1.0.0");
        await auto.hooks.beforeCommitChangelog.promise({
            bump: semver_1.default.major,
        });
        expect(execSpy).not.toHaveBeenCalledWith();
    });
    test("create old version branches", async () => {
        search.mockReturnValueOnce({ config: { versionBranches: true } });
        execSpy.mockResolvedValueOnce(undefined);
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        await auto.loadConfig();
        auto.hooks.getPreviousVersion.tap("test", () => "1.0.0");
        await auto.hooks.beforeCommitChangelog.promise({
            bump: semver_1.default.major,
            lastRelease: "1.0.0",
        });
        expect(execSpy).toHaveBeenCalledWith("git", [
            "branch",
            "version-1",
            "1.0.0",
        ]);
    });
    test("should be able to customize old version branches", async () => {
        search.mockReturnValueOnce({ config: { versionBranches: "v" } });
        execSpy.mockResolvedValueOnce(undefined);
        const auto = new auto_1.Auto(Object.assign(Object.assign({}, defaults), { plugins: [] }));
        await auto.loadConfig();
        auto.hooks.getPreviousVersion.tap("test", () => "1.0.0");
        await auto.hooks.beforeCommitChangelog.promise({
            bump: semver_1.default.major,
            lastRelease: "1.0.0",
        });
        expect(execSpy).toHaveBeenCalledWith("git", ["branch", "v1", "1.0.0"]);
    });
});
//# sourceMappingURL=major-version-branches.test.js.map