"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const release_1 = require("../release");
const semver_1 = tslib_1.__importStar(require("../semver"));
const semverMap = release_1.getVersionMap([
    ...semver_1.defaultLabels,
    { name: "documentation", releaseType: "skip" },
    { name: "none", releaseType: "none" },
]);
test("ranks releases right", () => {
    expect(semver_1.getHigherSemverTag(semver_1.default.major, semver_1.default.minor)).toBe("major");
    expect(semver_1.getHigherSemverTag(semver_1.default.noVersion, semver_1.default.patch)).toBe("patch");
    expect(semver_1.getHigherSemverTag(semver_1.default.minor, semver_1.default.patch)).toBe("minor");
});
describe("calculateSemVerBump", () => {
    test("should be able to use multiple labels for skip-release", () => {
        expect(semver_1.calculateSemVerBump([["skip-release", "major"]], semverMap)).toBe(semver_1.default.noVersion);
        expect(semver_1.calculateSemVerBump([["documentation", "major"]], semverMap)).toBe(semver_1.default.noVersion);
        expect(semver_1.calculateSemVerBump([["major"]], semverMap)).toBe(semver_1.default.major);
    });
    test("should skip none sometimes", () => {
        expect(semver_1.calculateSemVerBump([["none"]], semverMap)).toBe(semver_1.default.noVersion);
        expect(semver_1.calculateSemVerBump([["none", "major"]], semverMap)).toBe(semver_1.default.major);
        expect(semver_1.calculateSemVerBump([["none"], ["unknown"], ["documentation"]], semverMap)).toBe(semver_1.default.noVersion);
    });
    test("should release a patch for unlabeled pr merged along with none releases", () => {
        expect(semver_1.calculateSemVerBump([[], ["documentation"]], semverMap)).toBe(semver_1.default.patch);
    });
    test("should release a patch for pr with non-auto labels", () => {
        expect(semver_1.calculateSemVerBump([["a", "b", "c"], []], semverMap)).toBe(semver_1.default.patch);
    });
    test("should be able to configure default label", () => {
        expect(semver_1.calculateSemVerBump([[], ["documentation"]], semverMap, {
            labels: [{ default: true, name: "minor", releaseType: semver_1.default.minor }],
        })).toBe(semver_1.default.minor);
    });
    test("should be able to configure default no-version clean", () => {
        expect(semver_1.calculateSemVerBump([[], []], semverMap, {
            labels: [{ default: true, name: "docs", releaseType: "none" }],
        })).toBe(semver_1.default.noVersion);
    });
    test("should not skip things before none", () => {
        expect(semver_1.calculateSemVerBump([["none"], ["major"]], semverMap)).toBe(semver_1.default.major);
    });
    test("should respect onlyPublishWithReleaseLabel when no labels present on PR", () => {
        expect(semver_1.calculateSemVerBump([[]], semverMap, {
            onlyPublishWithReleaseLabel: true,
        })).toBe(semver_1.default.noVersion);
    });
    test("should respect onlyPublishWithReleaseLabel when no labels present on push to baseBranch", () => {
        expect(semver_1.calculateSemVerBump([], semverMap, {
            onlyPublishWithReleaseLabel: true,
        })).toBe(semver_1.default.noVersion);
    });
});
//# sourceMappingURL=semver.test.js.map