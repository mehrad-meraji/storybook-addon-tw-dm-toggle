"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePluginConfiguration = exports.validateAutoRc = exports.validateIoConfiguration = exports.validatePlugins = exports.formatError = void 0;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("io-ts"));
const Either_1 = require("fp-ts/lib/Either");
const types_1 = require("./types");
const omit_1 = require("./utils/omit");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const ignoreTypes = ["PartialType", "IntersectionType", "ExactType"];
const unexpectedValue = chalk_1.default.redBright.bold;
const errorPath = chalk_1.default.underline.bold;
/** Format and error as a string */
function formatError(error) {
    if (typeof error === "string") {
        return error;
    }
    const { path, expectedType, value } = error;
    const formattedValue = (Array.isArray(value) &&
        endent_1.default `
        [
          ${value.join(",\n")}
        ]
      `) ||
        (typeof value === "object" && JSON.stringify(value, null, 2)) ||
        value;
    return `${errorPath(`"${path}"`)}\n\nExpected ${chalk_1.default.greenBright.bold(expectedType)} but got: ${unexpectedValue(formattedValue)}\n`;
}
exports.formatError = formatError;
/** Report configuration errors */
function reporter(validation) {
    if (validation._tag !== "Left") {
        return false;
    }
    const errors = validation.left.map((error) => {
        let parentType = "";
        const path = error.context
            .filter((c) => {
            const tag = c.type._tag;
            const include = parentType === "ArrayType" ||
                (!ignoreTypes.includes(tag) &&
                    parentType !== "UnionType" &&
                    parentType !== "IntersectionType");
            parentType = tag;
            return c.key && include;
        })
            .map((c) => c.key)
            .join(".");
        return {
            path,
            expectedType: error.context[error.context.length - 1].type.name,
            value: error.value,
        };
    });
    const otherErrors = [];
    const grouped = errors.reduce((acc, item) => {
        if (typeof item === "string") {
            otherErrors.push(item);
            return acc;
        }
        if (!acc[item.path]) {
            acc[item.path] = [];
        }
        acc[item.path].push(item);
        return acc;
    }, {});
    const paths = Object.keys(grouped);
    return [
        ...otherErrors,
        ...Object.entries(grouped)
            .filter(([path]) => {
            return !paths.some((p) => p.includes(path) && p !== path);
        })
            .map(([path, group]) => {
            const expectedType = group
                .map((g) => g.expectedType)
                .map((t) => `"${t}"`)
                .join(" or ");
            const value = group[0].value;
            return {
                expectedType,
                path,
                value,
            };
        }),
    ];
}
/** Convert nested object to array of flat key paths */
function flatKeys(obj) {
    return Object.keys(obj)
        .map((key) => {
        if (typeof obj[key] === "object") {
            return flatKeys(obj[key]).map((sub) => `${key}.${sub}`);
        }
        return [key];
    })
        .reduce((acc, item) => acc.concat(item), []);
}
/** Ensure plugins validation is correct. */
async function validatePlugins(validatePlugin, rc) {
    const errors = [];
    if (!Array.isArray(rc.plugins)) {
        return [];
    }
    await Promise.all(rc.plugins.map(async (plugin) => {
        if (!Array.isArray(plugin)) {
            return;
        }
        const pluginErrors = await validatePlugin.promise(...plugin);
        if (pluginErrors) {
            errors.push(...pluginErrors);
        }
    }));
    return errors;
}
exports.validatePlugins = validatePlugins;
const shouldRecurse = [
    "PartialType",
    "IntersectionType",
    "ArrayType",
    "InterfaceType",
];
/**
 * Recurse through a io-ts type and make all objects exact.
 * This helps us check for additional properties.
 */
function makeExactType(configDeceleration) {
    let strictConfigDeclaration = configDeceleration;
    if ("props" in configDeceleration &&
        configDeceleration._tag !== "StrictType") {
        const props = {};
        Object.entries(configDeceleration.props).forEach(([propName, propType]) => {
            props[propName] = shouldRecurse.includes(propType._tag)
                ? makeExactType(propType)
                : propType;
        });
        strictConfigDeclaration = t.exact(configDeceleration._tag === "InterfaceType"
            ? t.interface(Object.assign({}, props))
            : t.partial(Object.assign({}, props)));
    }
    else if ("types" in configDeceleration) {
        const exactInterfaces = configDeceleration.types.map((propType) => shouldRecurse.includes(propType._tag) ? makeExactType(propType) : propType);
        strictConfigDeclaration =
            configDeceleration._tag === "IntersectionType"
                ? t.intersection(exactInterfaces)
                : t.union(exactInterfaces);
    }
    else if ("type" in configDeceleration) {
        strictConfigDeclaration = t.array(makeExactType(configDeceleration.type));
    }
    return strictConfigDeclaration;
}
/** Create a function to validation a configuration based on the configDeceleration  */
const validateIoConfiguration = (name, configDeceleration) => 
/** A function the will validate a configuration based on the configDeceleration */
async (rc) => {
    const looseRc = configDeceleration.decode(rc);
    const errors = reporter(looseRc);
    if (errors) {
        return errors;
    }
    const exactDeclaration = makeExactType(configDeceleration);
    const exactRc = exactDeclaration.decode(rc);
    if (!Either_1.isRight(looseRc) || !Either_1.isRight(exactRc)) {
        return [];
    }
    const correctKeys = flatKeys(exactRc.right);
    const unknownTopKeys = Object.keys(looseRc.right).filter((k) => !(k in exactRc.right));
    const unknownDeepKeys = flatKeys(omit_1.omit(looseRc.right, unknownTopKeys)).filter((k) => !correctKeys.includes(k));
    const unknownKeys = [...unknownTopKeys, ...unknownDeepKeys];
    if (unknownKeys.length === 0) {
        return [];
    }
    if (exactDeclaration._tag === "UnionType" &&
        "types" in exactDeclaration &&
        exactDeclaration.types.every((type) => type._tag === "IntersectionType" || type._tag === "ExactType")) {
        const decodedTypes = exactDeclaration.types.map((t) => t.decode(rc));
        const matchingMissingMember = decodedTypes.filter((t) => "left" in t)[0];
        if (matchingMissingMember && "left" in matchingMissingMember) {
            const correct = Object.keys(matchingMissingMember.left[0].context[0].actual);
            const missing = matchingMissingMember.left[0].context[matchingMissingMember.left[0].context.length - 1].key;
            return [
                `${errorPath(`"${name}"`)}\n\nFound missing configuration keys: when using ${chalk_1.default.greenBright.bold(correct.join(", "))} you must also provide ${unexpectedValue(missing)}\n`,
            ];
        }
        const matchingCorrectMember = decodedTypes.filter((t) => "right" in t &&
            Object.keys(t.right).length &&
            unknownKeys.every((u) => Object.keys(t.right).includes(u)))[0];
        if (matchingCorrectMember) {
            return [];
        }
    }
    return [
        `${errorPath(`"${name}"`)}\n\nFound unknown configuration keys: ${unexpectedValue(unknownKeys.join(", "))}\n`,
    ];
};
exports.validateIoConfiguration = validateIoConfiguration;
exports.validateAutoRc = exports.validateIoConfiguration(".autorc", types_1.autoRc);
/** Validate a plugin's configuration. */
async function validatePluginConfiguration(name, pluginDefinition, providedOptions) {
    const validateConfig = exports.validateIoConfiguration(name, pluginDefinition);
    const errors = await validateConfig(providedOptions);
    return errors.map((error) => {
        if (typeof error === "string") {
            return error;
        }
        return Object.assign(Object.assign({}, error), { path: error.path ? `${name}.${error.path}` : name });
    });
}
exports.validatePluginConfiguration = validatePluginConfiguration;
//# sourceMappingURL=validate-config.js.map