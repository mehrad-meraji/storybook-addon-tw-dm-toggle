"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSemVerBump = exports.getReleaseType = exports.getHigherSemverTag = exports.defaultLabels = exports.labelDefinition = exports.isVersionLabel = exports.releaseLabels = exports.preVersionMap = void 0;
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("io-ts"));
var SEMVER;
(function (SEMVER) {
    SEMVER["major"] = "major";
    SEMVER["premajor"] = "premajor";
    SEMVER["minor"] = "minor";
    SEMVER["preminor"] = "preminor";
    SEMVER["patch"] = "patch";
    SEMVER["prepatch"] = "prepatch";
    SEMVER["noVersion"] = "";
})(SEMVER || (SEMVER = {}));
exports.preVersionMap = new Map([
    [SEMVER.major, SEMVER.premajor],
    [SEMVER.minor, SEMVER.preminor],
    [SEMVER.patch, SEMVER.prepatch],
]);
exports.default = SEMVER;
exports.releaseLabels = [
    SEMVER.major,
    SEMVER.minor,
    SEMVER.patch,
    "skip",
    "release",
];
/** Determine if a label is a label used for versioning */
const isVersionLabel = (label) => exports.releaseLabels.includes(label);
exports.isVersionLabel = isVersionLabel;
const labelDefinitionRequired = t.type({
    /** The label text */
    name: t.string,
});
const releaseType = t.union([
    t.literal("none"),
    t.literal("skip"),
    ...exports.releaseLabels.map((l) => t.literal(l)),
]);
const labelDefinitionOptional = t.partial({
    /** A title to put in the changelog for the label */
    changelogTitle: t.string,
    /** The color of the label */
    color: t.string,
    /** The description of the label */
    description: t.string,
    /** What type of release this label signifies */
    releaseType,
    /** Whether to overwrite the base label */
    overwrite: t.boolean,
    /** Marks this label as the default label for unlabelled PRs */
    default: t.boolean,
});
exports.labelDefinition = t.intersection([
    labelDefinitionOptional,
    labelDefinitionRequired,
]);
const patchLabel = {
    name: "patch",
    changelogTitle: "🐛 Bug Fix",
    description: "Increment the patch version when merged",
    releaseType: SEMVER.patch,
    color: "#870048",
};
exports.defaultLabels = [
    {
        name: "major",
        changelogTitle: "💥 Breaking Change",
        description: "Increment the major version when merged",
        releaseType: SEMVER.major,
        color: "#C5000B",
    },
    {
        name: "minor",
        changelogTitle: "🚀 Enhancement",
        description: "Increment the minor version when merged",
        releaseType: SEMVER.minor,
        color: "#F1A60E",
    },
    patchLabel,
    {
        name: "skip-release",
        description: "Preserve the current version when merged",
        releaseType: "skip",
        color: "#bf5416",
    },
    {
        name: "release",
        description: "Create a release when this pr is merged",
        releaseType: "release",
        color: "#007f70",
    },
    {
        name: "internal",
        changelogTitle: "🏠 Internal",
        description: "Changes only affect the internal API",
        releaseType: "none",
        color: "#696969",
    },
    {
        name: "documentation",
        changelogTitle: "📝 Documentation",
        description: "Changes only affect the documentation",
        releaseType: "none",
        color: "#cfd3d7",
    },
    {
        name: "tests",
        changelogTitle: "🧪 Tests",
        description: "Add or improve existing tests",
        releaseType: "none",
        color: "#ffd3cc",
    },
    {
        name: "dependencies",
        changelogTitle: "🔩 Dependency Updates",
        description: "Update one or more dependencies version",
        releaseType: "none",
        color: "#8732bc",
    },
    {
        name: "performance",
        changelogTitle: "🏎 Performance",
        description: "Improve performance of an existing feature",
        releaseType: SEMVER.patch,
        color: "#f4b2d8",
    },
];
/** Given two labels determine the next SEMVER bump. */
function getHigherSemverTag(left, right) {
    if (left === SEMVER.major || right === SEMVER.major) {
        return SEMVER.major;
    }
    if (left === SEMVER.minor || right === SEMVER.minor) {
        return SEMVER.minor;
    }
    if (left === SEMVER.patch || right === SEMVER.patch) {
        return SEMVER.patch;
    }
    return SEMVER.noVersion;
}
exports.getHigherSemverTag = getHigherSemverTag;
/** Get the semver bump for a release type */
const getReleaseType = (releaseType) => releaseType === "none" || releaseType === "skip"
    ? SEMVER.noVersion
    : releaseType === "release"
        ? SEMVER.patch
        : releaseType || SEMVER.patch;
exports.getReleaseType = getReleaseType;
/**
 * Determine the version bump from the labels on merged PRs.
 * Respects skip-release labels and the "onlyPublishWithReleaseLabel"
 * strategy.
 */
function calculateSemVerBump(prLabels, labelMap, { onlyPublishWithReleaseLabel, labels = exports.defaultLabels, } = {}) {
    const defaultLabel = labels.find((l) => l.default) || patchLabel;
    const defaultReleaseType = defaultLabel.releaseType || SEMVER.patch;
    const releaseTypes = new Set();
    const skipReleaseLabels = labelMap.get("skip") || [];
    /** Find the release type + labels that match the given label */
    const getLabelEntry = (label) => [...labelMap.entries()].find((pair) => pair[1].includes(label));
    prLabels.forEach((pr, index) => {
        // Default to a patch when:
        // 1. No labels on HEAD PR
        // 2. It has labels but none of them are auto labels
        if (index === 0 &&
            (pr.length === 0 || !pr.some((label) => Boolean(getLabelEntry(label))))) {
            releaseTypes.add(defaultReleaseType);
        }
        pr.forEach((label) => {
            const userLabel = getLabelEntry(label);
            if (userLabel) {
                releaseTypes.add(userLabel[0]);
            }
        });
    });
    const lastMergedCommitLabels = prLabels[0] || [];
    const releaseLabels = labelMap.get("release") || [];
    const skipRelease = onlyPublishWithReleaseLabel
        ? !lastMergedCommitLabels.some((label) => releaseLabels.includes(label))
        : lastMergedCommitLabels.some((label) => skipReleaseLabels.includes(label));
    if (skipRelease) {
        return SEMVER.noVersion;
    }
    // If PRs only have none or skip labels, skip the release
    const onlyNoReleaseLabels = [...releaseTypes].reduce((condition, releaseType) => condition && (releaseType === "none" || releaseType === "skip"), true);
    if (releaseTypes.size > 0 && onlyNoReleaseLabels) {
        return SEMVER.noVersion;
    }
    return [...releaseTypes]
        .map(exports.getReleaseType)
        .reduce(getHigherSemverTag, exports.getReleaseType(defaultReleaseType));
}
exports.calculateSemVerBump = calculateSemVerBump;
//# sourceMappingURL=semver.js.map