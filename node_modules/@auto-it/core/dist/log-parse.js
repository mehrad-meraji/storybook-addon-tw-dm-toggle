"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSquashPR = exports.parsePR = void 0;
const make_hooks_1 = require("./utils/make-hooks");
/** Parse the PR information for the merge commit message */
function parsePR(commit) {
    const merge = /Merge pull request #(\d+) from (.+)\n([\S\s]+)/;
    const prMatch = commit.subject.match(merge);
    if (!prMatch) {
        return commit;
    }
    return Object.assign(Object.assign({}, commit), { pullRequest: {
            number: Number(prMatch[1]),
            base: prMatch[2],
        }, subject: prMatch[3].trim() });
}
exports.parsePR = parsePR;
/** Parse the PR information for the squashed commit message */
function parseSquashPR(commit) {
    const firstLine = commit.subject.split("\n")[0];
    const squashMerge = /\(#(\d+)\)$/;
    const squashMergeMatch = firstLine.match(squashMerge);
    if (!squashMergeMatch) {
        return commit;
    }
    return Object.assign(Object.assign({}, commit), { pullRequest: {
            number: Number(squashMergeMatch[1]),
        }, subject: firstLine
            .substr(0, firstLine.length - squashMergeMatch[0].length)
            .trim() });
}
exports.parseSquashPR = parseSquashPR;
/**
 * Parse the gitlog for commits that are PRs and attach their labels.
 * This class can also be tapped into via plugin to parse commits
 * in other ways (ex: conventional-commits)
 */
class LogParse {
    /** Initialize the log parser and tap the default functionality  */
    constructor() {
        this.hooks = make_hooks_1.makeLogParseHooks();
        this.hooks.parseCommit.tap("Merge Commit", parsePR);
        this.hooks.parseCommit.tap("Squash Merge Commit", parseSquashPR);
        this.hooks.parseCommit.tap("Strip consecutive white-space in Titles", (commit) => {
            const [firstLine, ...lines] = commit.subject.split("\n");
            commit.subject = [
                firstLine.replace(/[^\S\r\n]{2,}/g, " "),
                ...lines,
            ].join("\n");
            return commit;
        });
    }
    /** Run the log parser over a set of commits */
    async normalizeCommits(commits) {
        const eCommits = await Promise.all(commits.map(async (commit) => this.normalizeCommit(commit)));
        return eCommits.filter(Boolean);
    }
    /** Process a commit to find it's labels and PR information */
    async normalizeCommit(commit) {
        const extended = await this.hooks.parseCommit.promise(Object.assign(Object.assign({ labels: [] }, commit), { authors: [{ name: commit.authorName, email: commit.authorEmail }] }));
        const shouldOmit = await this.hooks.omitCommit.promise(extended);
        if (shouldOmit) {
            return;
        }
        return extended;
    }
}
exports.default = LogParse;
//# sourceMappingURL=log-parse.js.map