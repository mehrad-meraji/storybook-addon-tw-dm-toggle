"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeLabels = exports.normalizeLabel = exports.DEFAULT_PRERELEASE_BRANCHES = void 0;
const tslib_1 = require("tslib");
const cosmiconfig_1 = require("cosmiconfig");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const path = tslib_1.__importStar(require("path"));
const cosmiconfig_typescript_loader_1 = tslib_1.__importDefault(require("@endemolshinegroup/cosmiconfig-typescript-loader"));
const release_1 = require("./release");
const try_require_1 = tslib_1.__importDefault(require("./utils/try-require"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const semver_1 = require("./semver");
exports.DEFAULT_PRERELEASE_BRANCHES = ["next"];
/** Transform all types of label configuration into just 1 shape */
function normalizeLabel(label) {
    const baseLabel = semver_1.defaultLabels.find((l) => {
        let isBase = false;
        if (label.releaseType !== "none") {
            isBase = l.releaseType === label.releaseType;
        }
        return isBase || (label.name && l.name === label.name);
    }) || {};
    return Object.assign(Object.assign({}, baseLabel), label);
}
exports.normalizeLabel = normalizeLabel;
/**
 * Go through all the labels in a config and make them
 * follow the same format.
 */
function normalizeLabels(config) {
    if (config.labels) {
        if (config.noDefaultLabels) {
            return config.labels;
        }
        const userLabels = config.labels.map(normalizeLabel);
        const baseLabels = semver_1.defaultLabels.filter((d) => !userLabels.some((u) => u.releaseType && u.releaseType === d.releaseType && u.overwrite));
        return [...userLabels, ...baseLabels];
    }
    return semver_1.defaultLabels;
}
exports.normalizeLabels = normalizeLabels;
/** Load a user's configuration from the system and resolve any extended config */
class Config {
    /** Initialize the config loader */
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    async loadConfig() {
        const name = "auto";
        const explorer = cosmiconfig_1.cosmiconfig(name, {
            searchPlaces: [
                "package.json",
                `.${name}rc`,
                `.${name}rc.json`,
                `.${name}rc.yaml`,
                `.${name}rc.yml`,
                `.${name}rc.ts`,
                `.${name}rc.js`,
                `.${name}rc.cjs`,
                `${name}.config.js`,
                `${name}.config.cjs`,
                `${name}.config.ts`,
                `${name}.config.js`,
            ],
            loaders: {
                ".ts": cosmiconfig_typescript_loader_1.default,
            },
        });
        const result = await explorer.search();
        let rawConfig = {};
        if (result === null || result === void 0 ? void 0 : result.config) {
            rawConfig = result.config;
        }
        if (typeof rawConfig === "function") {
            rawConfig = await rawConfig();
        }
        if (rawConfig.extends) {
            rawConfig = deepmerge_1.default(rawConfig, await this.loadExtendConfig(rawConfig.extends));
        }
        this.checkDeprecated(rawConfig);
        const labels = normalizeLabels(rawConfig);
        const semVerLabels = release_1.getVersionMap(labels);
        this.logger.verbose.success("Using SEMVER labels:", "\n", semVerLabels);
        return Object.assign(Object.assign({}, rawConfig), { labels, prereleaseBranches: rawConfig.prereleaseBranches || exports.DEFAULT_PRERELEASE_BRANCHES, versionBranches: typeof rawConfig.versionBranches === "boolean" &&
                rawConfig.versionBranches
                ? "version-"
                : rawConfig.versionBranches });
    }
    /**
     * Loads a config from a path, package name, or special `auto-config` pattern
     *
     * ex: auto-config-MY_CONFIG
     * ex: @MY_CONFIG/auto-config
     *
     * @param extend - Path or name of config to find
     */
    async loadExtendConfig(extend) {
        var _a;
        let config;
        if (extend.endsWith(".js") || extend.endsWith(".mjs")) {
            throw new Error("Extended config cannot be a JavaScript file");
        }
        if (extend.startsWith("http")) {
            try {
                config = (await node_fetch_1.default(extend)).json();
                this.logger.verbose.note(`${extend} found: ${config}`);
            }
            catch (error) {
                error.message = `Failed to get extended config from ${extend} -- ${error.message}`;
                throw error;
            }
        }
        else if (extend.startsWith(".")) {
            config = try_require_1.default(extend);
            if (extend.endsWith("package.json")) {
                config = config === null || config === void 0 ? void 0 : config.auto;
            }
            this.logger.verbose.note(`${extend} found: ${config}`);
        }
        else {
            config = (_a = try_require_1.default(`${extend}/package.json`)) === null || _a === void 0 ? void 0 : _a.auto;
            this.logger.verbose.note(`${extend} found: ${config}`);
        }
        if (!config) {
            const scope = `${extend}/auto-config/package.json`;
            config = try_require_1.default(scope);
            config = config === null || config === void 0 ? void 0 : config.auto;
            this.logger.verbose.note(`${scope} found: ${config}`);
            if (config) {
                config.extends = scope;
            }
        }
        if (!config) {
            const scope = `auto-config-${extend}/package.json`;
            config = try_require_1.default(scope);
            config = config === null || config === void 0 ? void 0 : config.auto;
            this.logger.verbose.note(`${scope} found: ${config}`);
            if (config) {
                config.extends = scope;
            }
        }
        if (!config) {
            const localPath = path.join(process.cwd(), extend);
            config = try_require_1.default(localPath);
            if (config) {
                config.extends = localPath;
            }
        }
        if (!config) {
            config = try_require_1.default(extend);
            this.logger.verbose.note(`${extend} found: ${config}`);
            if (config) {
                config.extends = extend;
            }
        }
        if (!config) {
            throw new Error(`Unable to load extended config ${extend}`);
        }
        return config;
    }
    /** Ensure a user's config is not using deprecated options. */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    checkDeprecated(config) {
        if (config.labels && !Array.isArray(config.labels)) {
            this.logger.log.error(endent_1.default `
        You're using a deprecated configuration option!

        The "labels" option no longer supports configuration with an object.
        Instead supply your labels as an array of label objects.

        ex:

        |  {
        |    "labels": [
        |      {
        |        "name": "my-label",
        |        "description": "Really big stuff",
        |        "type": "major"
        |      }
        |    ]
        |  }
      `);
            process.exit(1);
        }
        if (config.skipReleaseLabels) {
            this.logger.log.error(endent_1.default `
        You're using a deprecated configuration option!

        The "skipReleaseLabels" option no longer exists.
        Instead set "type" to "skip" in your label configuration.

        ex:

        |  {
        |    "labels": [
        |      {
        |        "name": "my-label",
        |        "description": "Really big stuff",
        |        "type": "skip"
        |      }
        |    ]
        |  }
      `);
            process.exit(1);
        }
    }
}
exports.default = Config;
//# sourceMappingURL=config.js.map