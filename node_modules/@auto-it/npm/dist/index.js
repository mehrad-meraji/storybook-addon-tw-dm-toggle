"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonorepoPackage = exports.getChangedPackages = exports.greaterRelease = void 0;
const tslib_1 = require("tslib");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const fs = tslib_1.__importStar(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const typescript_memoize_1 = require("typescript-memoize");
const t = tslib_1.__importStar(require("io-ts"));
const child_process_1 = require("child_process");
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const core_1 = require("@auto-it/core");
const get_monorepo_packages_1 = tslib_1.__importDefault(require("get-monorepo-packages"));
const semver_1 = require("semver");
const package_json_utils_1 = require("@auto-it/package-json-utils");
const set_npm_token_1 = tslib_1.__importStar(require("./set-npm-token"));
const utils_1 = require("./utils");
const { isCi } = env_ci_1.default();
/** Get the last published version for a npm package */
async function getPublishedVersion(name) {
    try {
        return await core_1.execPromise("npm", [
            "view",
            name,
            "version",
            "--registry",
            await set_npm_token_1.getRegistry(),
        ]);
    }
    catch (error) { }
}
/**
 * Determine the greatest version between @latest published version of a
 * package and the version in the package.json.
 */
async function greaterRelease(prefixRelease, name, packageVersion, prereleaseBranch) {
    const publishedVersion = await getPublishedVersion(name);
    if (!publishedVersion) {
        return packageVersion;
    }
    // If @latest published version is a pre-release,
    // this means the package has not been published as a stable tag yet
    // Prefer local version to prevent a new package from adjusting the versions for a whole monorepo.
    if (semver_1.prerelease(publishedVersion) !== null) {
        return packageVersion;
    }
    const publishedPrefixed = prefixRelease(publishedVersion);
    // The branch (ex: next) is also the --preid
    const baseVersion = prereleaseBranch && packageVersion.includes(prereleaseBranch)
        ? semver_1.inc(packageVersion, "patch") || packageVersion
        : packageVersion;
    return semver_1.gte(baseVersion, publishedPrefixed)
        ? packageVersion
        : publishedPrefixed;
}
exports.greaterRelease = greaterRelease;
/**
 * Determine what packages in a monorepo have git changes.
 * We are specifically not using `lerna changed` here because
 * we only care about the package that changed, not what other
 * packages that might effect.
 */
async function getChangedPackages({ sha, packages, addVersion, logger, version, }) {
    const changed = new Set();
    const changedFiles = child_process_1.execSync(`git --no-pager show --first-parent ${sha} --name-only --pretty=`, { encoding: "utf8" });
    changedFiles.split("\n").forEach((filePath) => {
        const monorepoPackage = packages.find((subPackage) => core_1.inFolder(subPackage.path, filePath));
        if (!monorepoPackage) {
            return;
        }
        changed.add(addVersion
            ? `${monorepoPackage.name}@${semver_1.inc(monorepoPackage.version, version)}`
            : monorepoPackage.name);
    });
    if (changed.size > 0) {
        logger.veryVerbose.info(`Got changed packages for ${sha}:\n`, changed);
    }
    return [...changed];
}
exports.getChangedPackages = getChangedPackages;
/** Get the package with the greatest version in a monorepo */
function getMonorepoPackage() {
    const packages = get_monorepo_packages_1.default(process.cwd());
    if (!packages.length) {
        return {};
    }
    // Remove pre-releases so that released package versions take precedence
    let releasedPackages = packages.filter(subPackage => { var _a; return semver_1.prerelease(((_a = subPackage.package) === null || _a === void 0 ? void 0 : _a.version) || '') === null; });
    // If doing this would remove all packages, this means were not any @latest releases yet
    // In that case, restore the original list of packages.
    if (releasedPackages.length === 0) {
        releasedPackages = packages;
    }
    const monorepoPackage = releasedPackages.reduce((greatest, subPackage) => {
        if (subPackage.package.version) {
            if (!greatest.package.version) {
                return subPackage;
            }
            if (subPackage.package.private) {
                return greatest;
            }
            return semver_1.gt(greatest.package.version, subPackage.package.version)
                ? greatest
                : subPackage;
        }
        return greatest;
    });
    return monorepoPackage.package;
}
exports.getMonorepoPackage = getMonorepoPackage;
/** Get all of the packages+version in the lerna monorepo */
async function getPackageList() {
    return core_1.getLernaPackages().then((packages) => packages.map((p) => `${p.name}@${p.version.split("+")[0]}`));
}
/**
 * Increment the version number of a package based the bigger
 * release between the last published version and the version
 * in the package.json.
 */
async function bumpLatest({ version: localVersion, name }, version) {
    const latestVersion = localVersion
        ? await greaterRelease((s) => s, name, localVersion)
        : undefined;
    return latestVersion ? semver_1.inc(latestVersion, version) : version;
}
/** Get the args to use legacy auth */
function getLegacyAuthArgs(useLegacy, options = {}) {
    if (!useLegacy) {
        return [];
    }
    return options.isMonorepo
        ? ["--legacy-auth", process.env.NPM_TOKEN]
        : [`--_auth=${process.env.NPM_TOKEN}`];
}
/** Get args for publishFolder */
function getPublishFolderArgs(publishFolder, options = {}) {
    if (!publishFolder) {
        return [];
    }
    return options.isMonorepo
        ? ["--contents", publishFolder]
        : [publishFolder];
}
/** Get the args to set the registry. Only used with lerna */
async function getRegistryArgs() {
    const registry = await set_npm_token_1.getRegistry();
    return registry === set_npm_token_1.DEFAULT_REGISTRY || !registry
        ? []
        : ["--registry", registry];
}
const pluginOptions = t.partial({
    /** Whether to create sub-package changelogs */
    subPackageChangelogs: t.boolean,
    /** Whether to create a commit for "next" version. The default behavior will only create the tags */
    commitNextVersion: t.boolean,
    /** Whether to set the npm token on CI */
    setRcToken: t.boolean,
    /** Whether to force publish all the packages in a monorepo */
    forcePublish: t.boolean,
    /** A scope to publish canary versions under */
    canaryScope: t.string,
    /** Publish a monorepo with the lerna --exact flag */
    exact: t.boolean,
    /**
     * When publishing packages that require authentication but you are working with an internally
     * hosted NPM Registry that only uses the legacy Base64 version of username:password. This is
     * the same as the NPM publish _auth flag.
     */
    legacyAuth: t.boolean,
    /** Whether to add package information to monorepo changelogs */
    monorepoChangelog: t.boolean,
    /**
     * Path used when publishing packages.
     * When used with npm this is equivalent to npm publish <publishFolder>
     * When used with lerna this is equivalent to lerna publish --contents <publishFolder>
     */
    publishFolder: t.string,
});
/** Render a list of string in markdown */
const markdownList = (lines) => lines.map((line) => `- \`${line}\``).join("\n");
/** Get the previous version. Typically from a package distribution description file. */
async function getPreviousVersion(auto, prereleaseBranch, isMaintenanceBranch) {
    let previousVersion = "";
    if (utils_1.isMonorepo()) {
        auto.logger.veryVerbose.info("Using monorepo to calculate previous release");
        const monorepoVersion = utils_1.getLernaJson().version;
        if (monorepoVersion === "independent") {
            previousVersion =
                "dryRun" in auto.options && auto.options.dryRun
                    ? markdownList(await getPackageList())
                    : "";
        }
        else {
            const releasedPackage = getMonorepoPackage();
            if (isMaintenanceBranch || (!releasedPackage.name && !releasedPackage.version)) {
                previousVersion = auto.prefixRelease(monorepoVersion);
            }
            else {
                previousVersion = await greaterRelease(auto.prefixRelease, releasedPackage.name, auto.prefixRelease(monorepoVersion), prereleaseBranch);
            }
        }
    }
    else if (fs.existsSync("package.json")) {
        auto.logger.veryVerbose.info("Using package.json to calculate previous version");
        const { version, name } = await package_json_utils_1.loadPackageJson();
        if (isMaintenanceBranch && version) {
            previousVersion = version;
        }
        else {
            previousVersion = version
                ? await greaterRelease(auto.prefixRelease, name, auto.prefixRelease(version), prereleaseBranch)
                : "0.0.0";
        }
    }
    auto.logger.verbose.info("NPM: Got previous version from package.json", previousVersion);
    return previousVersion;
}
/** Remove the @ sign */
const sanitizeScope = (canaryScope) => canaryScope.replace("@", "");
/** Add a npm scope to a package name. Can have leading @ or not. */
const addCanaryScope = (canaryScope, name) => `@${sanitizeScope(canaryScope)}/${name}`;
/** Change the scope of all the packages to the canary scope */
async function setCanaryScope(canaryScope, paths) {
    const packages = await Promise.all(paths.map(async (p) => [p, await package_json_utils_1.loadPackageJson(p)]));
    const names = packages.map(([, p]) => p.name);
    await Promise.all(packages.map(async ([p, packageJson]) => {
        const newJson = Object.assign({}, packageJson);
        const name = packageJson.name.match(/@\S+\/\S+/)
            ? packageJson.name.split("/")[1]
            : packageJson.name;
        newJson.name = addCanaryScope(canaryScope, name);
        if (newJson.dependencies) {
            Object.keys(newJson.dependencies).forEach((d) => {
                if (names.includes(d)) {
                    const depName = d.match(/@\S+\/\S+/) ? d.split("/")[1] : d;
                    newJson.dependencies[addCanaryScope(canaryScope, depName)] = newJson.dependencies[d];
                    delete newJson.dependencies[d];
                }
            });
        }
        await utils_1.writeFile(path_1.default.join(p, "package.json"), JSON.stringify(newJson, null, 2));
    }));
}
/** Reset the scope changes of all the packages  */
async function gitReset() {
    await core_1.execPromise("git", ["reset", "--hard", "HEAD"]);
}
/** Make install instructions for multiple repos */
const makeMonorepoInstallList = (packageList) => [
    ":sparkles: Test out this PR locally via:\n",
    "```bash",
    ...packageList.map((p) => `npm install ${p}`),
    "# or ",
    ...packageList.map((p) => `yarn add ${p}`),
    "```",
].join("\n");
/** Get an array of independent next version package updates */
const getIndependentNextReleases = async (bump, prereleaseBranch) => {
    const packages = await core_1.getLernaPackages();
    const [, changedPackagesResult = ""] = await await_to_js_1.default(core_1.execPromise("npx", ["lerna", "changed", "-a"]));
    const changedPackages = changedPackagesResult
        .split("\n")
        .map((changedPackage) => changedPackage.replace("(PRIVATE)", "").trim())
        .filter((changedPackage) => packages.some((p) => p.name === changedPackage));
    const allTags = (await core_1.execPromise("git", ["tag", "--sort='creatordate'"]))
        .split("\n")
        .reverse();
    if (!changedPackages.length) {
        return;
    }
    // Get all version updates
    const updates = await Promise.all(changedPackages.map(async (p) => {
        const lernaPackage = packages.find((pack) => pack.name === p);
        if (!lernaPackage) {
            return;
        }
        const currentVersion = (lernaPackage === null || lernaPackage === void 0 ? void 0 : lernaPackage.version) || "0.0.0";
        const name = `${p}@`;
        const lastTag = allTags.find((tag) => tag.startsWith(name)) || currentVersion;
        const lastVersion = lastTag.replace(name, "");
        return Object.assign(Object.assign({}, lernaPackage), { newVersion: core_1.determineNextVersion(currentVersion, lastVersion, bump, prereleaseBranch) });
    }));
    return updates.filter((p) => Boolean(p));
};
/** Apply updates to inter dependencies  */
const updateDependencies = (packageJson, type, updates) => {
    const deps = packageJson[type];
    if (!deps) {
        return;
    }
    Object.entries(deps).forEach(([name, version]) => {
        if (typeof version !== "string" ||
            version.startsWith("link:") ||
            version.startsWith("file:")) {
            return;
        }
        const depUpdate = updates.find((update) => update.name === name);
        if (depUpdate && version.includes(depUpdate.version)) {
            deps[name] = version.replace(depUpdate.version, depUpdate.newVersion);
        }
    });
};
/** Find changed packages and create a tag for the current next release. */
const tagIndependentNextReleases = async (bump, prereleaseBranch) => {
    // Get all version updates
    const updates = await getIndependentNextReleases(bump, prereleaseBranch);
    if (!updates || !updates.length) {
        return;
    }
    // Update package.json
    await Promise.all(updates.map(async (lernaPackage) => {
        if (!lernaPackage) {
            return;
        }
        const packageJsonPath = path_1.default.join(lernaPackage.path, "package.json");
        const packageJson = JSON.parse(await utils_1.readFile(packageJsonPath, {
            encoding: "utf-8",
        }));
        packageJson.version = lernaPackage.newVersion;
        updateDependencies(packageJson, "dependencies", updates);
        updateDependencies(packageJson, "devDependencies", updates);
        await utils_1.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
    }));
    // Commit work
    await core_1.execPromise("git", ["commit", "-am", "'Update versions'"]);
    // Create tags will be rolled back in the next hook
    await Promise.all(updates.map(async (lernaPackage) => {
        if (!lernaPackage) {
            return;
        }
        const newTag = `${lernaPackage.name}@${lernaPackage.newVersion}`;
        await core_1.execPromise("git", [
            "tag",
            "-a",
            "-m",
            `"Update version to ${newTag}"`,
            newTag,
        ]);
    }));
};
/** Find an available canary version to publish */
const findAvailableCanaryVersion = async (auto, packageName, startVersion) => {
    let canaryVersion = startVersion;
    // eslint-disable-next-line no-await-in-loop
    while (await getPublishedVersion(`${packageName}@${canaryVersion}`)) {
        auto.logger.verbose.info(`Version "${canaryVersion}" is taken! Trying another...`);
        canaryVersion = semver_1.inc(canaryVersion, "prerelease");
    }
    auto.logger.verbose.info(`Version "${canaryVersion}" is available!`);
    return canaryVersion;
};
/** Publish to NPM. Works in both a monorepo setting and for a single package. */
class NPMPlugin {
    /** Initialize the plugin with it's options */
    constructor(config = {}) {
        var _a, _b, _c, _d, _e;
        /** The name of the plugin */
        this.name = "npm";
        this.legacyAuth = Boolean(config.legacyAuth);
        this.exact = Boolean(config.exact);
        this.monorepoChangelog = (_a = config.monorepoChangelog) !== null && _a !== void 0 ? _a : true;
        this.subPackageChangelogs = (_b = config.subPackageChangelogs) !== null && _b !== void 0 ? _b : true;
        this.setRcToken = (_c = config.setRcToken) !== null && _c !== void 0 ? _c : true;
        this.forcePublish = (_d = config.forcePublish) !== null && _d !== void 0 ? _d : true;
        this.commitNextVersion = (_e = config.commitNextVersion) !== null && _e !== void 0 ? _e : false;
        this.canaryScope = config.canaryScope || undefined;
        this.publishFolder = config.publishFolder || undefined;
    }
    /** A memoized version of getLernaPackages */
    async getLernaPackages() {
        return core_1.getLernaPackages();
    }
    /** Custom initialization for this plugin */
    init(initializer) {
        initializer.hooks.createEnv.tap(this.name, (vars) => [
            ...vars,
            {
                variable: "NPM_TOKEN",
                message: `Enter a npm token for publishing packages https://docs.npmjs.com/creating-and-viewing-authentication-tokens`,
            },
        ]);
        initializer.hooks.getAuthor.tapPromise(this.name, async () => {
            const packageJson = await package_json_utils_1.loadPackageJson();
            if (packageJson.author) {
                return true;
            }
            const author = await initializer.getAuthorInformation();
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.author = `${author.name} <${author.email}>`;
            await utils_1.writeFile("package.json", JSON.stringify(newPackageJson, null, 2));
            return true;
        });
        initializer.hooks.getRepo.tapPromise(this.name, async () => {
            const packageJson = await package_json_utils_1.loadPackageJson();
            if (packageJson.repository) {
                return true;
            }
            const repository = await initializer.getRepoInformation();
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.repository = `${repository.owner}/${repository.repo}`;
            await utils_1.writeFile("package.json", JSON.stringify(newPackageJson, null, 2));
            return true;
        });
        initializer.hooks.writeRcFile.tapPromise(this.name, async (rc) => {
            const packageJson = await package_json_utils_1.loadPackageJson();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (packageJson.auto) {
                initializer.logger.log.note("Would have wrote configuration:\n", JSON.stringify(rc, null, 2));
                initializer.logger.log.warn("Found auto configuration in package.json. Doing nothing.");
            }
            else {
                await utils_1.writeFile("package.json", JSON.stringify(Object.assign(Object.assign({}, packageJson), { auto: rc }), null, 2));
                initializer.logger.log.success("Wrote configuration to package.json");
            }
            return true;
        });
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        var _a, _b;
        const isQuiet = auto.logger.logLevel === "quiet";
        const isVerbose = auto.logger.logLevel === "verbose" ||
            auto.logger.logLevel === "veryVerbose";
        const verboseArgs = isQuiet
            ? ["--loglevel", "silent"]
            : isVerbose
                ? ["--loglevel", "silly"]
                : [];
        const prereleaseBranches = ((_a = auto.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches) || core_1.DEFAULT_PRERELEASE_BRANCHES;
        const branch = core_1.getCurrentBranch();
        // if ran from baseBranch we publish the prerelease to the first
        // configured prerelease branch
        const prereleaseBranch = branch && prereleaseBranches.includes(branch)
            ? branch
            : prereleaseBranches[0];
        let isMaintenanceBranch = false;
        if (((_b = auto.config) === null || _b === void 0 ? void 0 : _b.versionBranches) && branch) {
            isMaintenanceBranch = branch.includes(typeof auto.config.versionBranches === "boolean" ? "version-" : auto.config.versionBranches);
        }
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            if (name === this.name || name === `@auto-it/${this.name}`) {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.modifyConfig.tap(this.name, (config) => {
            if (utils_1.isMonorepo()) {
                const lernaJson = utils_1.getLernaJson();
                if (lernaJson.tagVersionPrefix === "") {
                    return Object.assign(Object.assign({}, config), { noVersionPrefix: true });
                }
            }
            return config;
        });
        auto.hooks.beforeShipIt.tap(this.name, async ({ releaseType }) => {
            this.releaseType = releaseType;
            const isIndependent = utils_1.getLernaJson().version === "independent";
            // In independent mode it's possible that no changes to packages have been
            // made, so no release will be made.
            if (isIndependent) {
                try {
                    await core_1.execPromise("npx", ["lerna", "updated", "-a"]);
                }
                catch (error) {
                    auto.logger.log.warn("Lerna detected no changes in project. Aborting release since nothing would be published.");
                    auto.logger.verbose.warn(error);
                    process.exit(0);
                }
            }
            if (!isCi) {
                return;
            }
            const { private: isPrivate } = await package_json_utils_1.loadPackageJson();
            if (isPrivate) {
                return;
            }
            // gh-action + node action uses NODE_AUTH_TOKEN and we should warn about NPM_TOKEN
            if (!process.env.NODE_AUTH_TOKEN) {
                auto.checkEnv(this.name, "NPM_TOKEN");
            }
        });
        auto.hooks.getAuthor.tapPromise(this.name, async () => {
            auto.logger.verbose.info("NPM: Getting repo information from package.json");
            const author = await package_json_utils_1.getAuthor();
            if (author) {
                return author;
            }
        });
        auto.hooks.getPreviousVersion.tapPromise(this.name, () => getPreviousVersion(auto, prereleaseBranch, isMaintenanceBranch));
        auto.hooks.getRepository.tapPromise(this.name, async () => {
            auto.logger.verbose.info("NPM: getting repo information from package.json");
            const repo = await package_json_utils_1.getRepo();
            if (repo) {
                return repo;
            }
        });
        auto.hooks.onCreateRelease.tap(this.name, (release) => {
            release.hooks.createChangelogTitle.tap(`${this.name} - lerna independent`, () => {
                if (utils_1.isMonorepo() && utils_1.getLernaJson().version === "independent") {
                    return "";
                }
            });
        });
        auto.hooks.onCreateChangelog.tap(this.name, (changelog, { bump = core_1.SEMVER.patch }) => {
            changelog.hooks.renderChangelogLine.tapPromise("NPM - Monorepo", async (line, commit) => {
                if (!utils_1.isMonorepo() || !this.monorepoChangelog) {
                    return line;
                }
                // Allows us to see the commit being assessed
                auto.logger.veryVerbose.info(`Rendering changelog line for commit:`, commit);
                // adds commits to changelog only if hash is resolvable
                if (!commit || !commit.hash) {
                    return line;
                }
                const lernaPackages = await this.getLernaPackages();
                const changedPackages = await getChangedPackages({
                    sha: commit.hash,
                    packages: lernaPackages,
                    // If we are making a next release it's hard to get the independent next
                    // versions to put in the changelog so we just omit them
                    addVersion: this.releaseType !== "next" &&
                        utils_1.getLernaJson().version === "independent",
                    logger: auto.logger,
                    version: bump,
                });
                const section = (changedPackages === null || changedPackages === void 0 ? void 0 : changedPackages.length)
                    ? changedPackages.map((p) => `\`${p}\``).join(", ")
                    : "monorepo";
                if (section === "monorepo") {
                    return line;
                }
                return [`- ${section}`, `  ${line}`].join("\n");
            });
            changelog.hooks.sortChangelogLines.tap("NPM - Monorepo Grouping", (lines) => {
                if (!utils_1.isMonorepo() || !this.monorepoChangelog) {
                    return lines;
                }
                const lineMap = {};
                lines.forEach((line) => {
                    const monoRepoLine = line.split("\n");
                    if (monoRepoLine.length === 1) {
                        if (!lineMap.root) {
                            lineMap.root = [];
                        }
                        lineMap.root.push(line);
                    }
                    else {
                        const [packageName, change] = monoRepoLine;
                        if (!lineMap[packageName]) {
                            lineMap[packageName] = [];
                        }
                        lineMap[packageName].push(change);
                    }
                });
                return Object.entries(lineMap).map(([packageName, changes]) => {
                    if (packageName === "root") {
                        return changes.join("\n");
                    }
                    return [packageName, ...changes].join("\n");
                });
            });
        });
        auto.hooks.beforeCommitChangelog.tapPromise(this.name, async ({ commits, bump }) => {
            if (!utils_1.isMonorepo() || !auto.release || !this.subPackageChangelogs) {
                return;
            }
            const [, changedPackagesResult = ""] = await await_to_js_1.default(core_1.execPromise("npx", ["lerna", "changed"]));
            const changedPackages = changedPackagesResult.split("\n");
            if (!changedPackages.length) {
                return;
            }
            const lernaPackages = await core_1.getLernaPackages();
            const changelog = await auto.release.makeChangelog(bump);
            const monorepoChangelogSetting = this.monorepoChangelog;
            this.monorepoChangelog = false;
            // Cannot run git operations in parallel
            await lernaPackages.reduce(async (last, lernaPackage) => {
                await last;
                // If lerna doesn't think a package has changed then do not create sub-package changelog
                // Since we use "git log -m", merge commits can have lots of files in them. Lerna does not
                // use this option. This means that this hooks will only create a sub-package changelog if
                // lerna will publish an update for it
                if (!changedPackages.some((name) => lernaPackage.name === name)) {
                    return;
                }
                auto.logger.verbose.info(`Updating changelog for: ${lernaPackage.name}`);
                const includedCommits = commits.filter((commit) => commit.files.some((file) => core_1.inFolder(lernaPackage.path, file)));
                const title = `v${semver_1.inc(lernaPackage.version, bump)}`;
                const releaseNotes = await changelog.generateReleaseNotes(includedCommits);
                if (releaseNotes.trim()) {
                    await auto.release.updateChangelogFile(title, releaseNotes, path_1.default.join(lernaPackage.path, "CHANGELOG.md"));
                }
            }, Promise.resolve());
            this.monorepoChangelog = monorepoChangelogSetting;
        });
        auto.hooks.version.tapPromise(this.name, async ({ bump, useVersion, dryRun, quiet }) => {
            var _a, _b;
            const isBaseBranch = branch === auto.baseBranch;
            /** Log the version */
            const logVersion = (version) => {
                if (quiet) {
                    console.log(version);
                }
                else {
                    auto.logger.log.info(`Would have published: ${version}`);
                }
            };
            if (utils_1.isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const lernaJson = utils_1.getLernaJson();
                const monorepoVersion = lernaJson.version;
                const isIndependent = monorepoVersion === "independent";
                if (dryRun) {
                    if (isIndependent) {
                        await core_1.execPromise("npx", [
                            "lerna",
                            "version",
                            useVersion || bump,
                            ...(await getRegistryArgs()),
                            ...getLegacyAuthArgs(this.legacyAuth, { isMonorepo: true }),
                            "--yes",
                            "--no-push",
                            "--no-git-tag-version",
                            "--no-commit-hooks",
                            "--exact",
                            "--ignore-scripts",
                            ...verboseArgs,
                        ]);
                        const canaryPackageList = await getPackageList();
                        // Reset after we read the packages from the system!
                        await gitReset();
                        logVersion(canaryPackageList.join("\n"));
                    }
                    else {
                        logVersion(useVersion || semver_1.inc(monorepoVersion, bump) || bump);
                    }
                    return;
                }
                const monorepoBump = isIndependent || !isBaseBranch
                    ? useVersion || bump
                    : useVersion || (await bumpLatest(getMonorepoPackage(), bump)) || bump;
                let commitMessage = isIndependent
                    ? "Bump independent versions [skip ci]"
                    : "Bump version to: %s [skip ci]";
                const customCommitMessage = (_b = (_a = lernaJson.command) === null || _a === void 0 ? void 0 : _a.version) === null || _b === void 0 ? void 0 : _b.message;
                if (typeof customCommitMessage === "string") {
                    commitMessage = customCommitMessage.trim();
                    if (customCommitMessage.indexOf("[skip ci]") === -1) {
                        commitMessage += " [skip ci]";
                    }
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "version",
                    monorepoBump,
                    !isIndependent && this.forcePublish && "--force-publish",
                    "--no-commit-hooks",
                    "--yes",
                    "--no-push",
                    "-m",
                    `'"${commitMessage}"'`,
                    this.exact && "--exact",
                    ...verboseArgs,
                ]);
                auto.logger.verbose.info("Successfully versioned repo");
                return;
            }
            const latestBump = isBaseBranch
                ? useVersion || (await bumpLatest(await package_json_utils_1.loadPackageJson(), bump)) || bump
                : useVersion || bump;
            if (dryRun) {
                logVersion(latestBump);
                return;
            }
            await core_1.execPromise("npm", [
                "version",
                latestBump,
                "--no-commit-hooks",
                "-m",
                "'Bump version to: %s [skip ci]'",
                ...verboseArgs,
            ]);
            auto.logger.verbose.info("Successfully versioned repo");
        });
        auto.hooks.canary.tapPromise(this.name, async ({ bump, canaryIdentifier, dryRun, quiet }) => {
            if (this.setRcToken) {
                await this.setTokenOnCI(auto);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            const lastRelease = await auto.git.getLatestRelease();
            const [, latestTag = lastRelease] = await await_to_js_1.default(auto.git.getLatestTagInBranch());
            const inPrerelease = prereleaseBranches.some((b) => latestTag.includes(`-${b}.`));
            /** Log the version */
            const logVersion = (version) => {
                if (quiet) {
                    console.log(version);
                }
                else {
                    auto.logger.log.info(`Would have published: ${version}`);
                }
            };
            if (utils_1.isMonorepo()) {
                const isIndependent = utils_1.getLernaJson().version === "independent";
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const packagesBefore = await core_1.getLernaPackages();
                let canaryVersion = (isIndependent && `pre${bump}`) ||
                    core_1.determineNextVersion(lastRelease, inPrerelease ? latestTag : packagesBefore[0].version, bump, canaryIdentifier);
                if (this.canaryScope && !dryRun) {
                    await setCanaryScope(this.canaryScope, packagesBefore.map((p) => p.path));
                }
                if (!isIndependent) {
                    const { name } = getMonorepoPackage();
                    canaryVersion = await findAvailableCanaryVersion(auto, name, canaryVersion);
                    if (dryRun) {
                        logVersion(canaryVersion);
                        return;
                    }
                    // Is independent and a dry run
                }
                else if (dryRun) {
                    await core_1.execPromise("npx", [
                        "lerna",
                        "version",
                        canaryVersion,
                        ...(await getRegistryArgs()),
                        ...getLegacyAuthArgs(this.legacyAuth, { isMonorepo: true }),
                        "--yes",
                        "--no-push",
                        "--no-git-tag-version",
                        "--no-commit-hooks",
                        "--exact",
                        "--ignore-scripts",
                        "--preid",
                        canaryIdentifier.replace(/^-/, ""),
                        ...verboseArgs,
                    ]);
                    const canaryPackageList = await getPackageList();
                    // Reset after we read the packages from the system!
                    await gitReset();
                    logVersion(canaryPackageList.join("\n"));
                    return;
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    canaryVersion,
                    "--dist-tag",
                    "canary",
                    ...(await getRegistryArgs()),
                    ...getPublishFolderArgs(this.publishFolder, { isMonorepo: true }),
                    !isIndependent && "--force-publish",
                    ...getLegacyAuthArgs(this.legacyAuth, { isMonorepo: true }),
                    "--yes",
                    "--no-git-reset",
                    "--no-git-tag-version",
                    "--exact",
                    "--no-verify-access",
                    ...(isIndependent
                        ? ["--preid", canaryIdentifier.replace(/^-/, "")]
                        : []),
                    ...verboseArgs,
                ]);
                auto.logger.verbose.info("Successfully published canary version");
                const packages = await core_1.getLernaPackages();
                const packageList = await getPackageList();
                // Reset after we read the packages from the system!
                await gitReset();
                if (isIndependent) {
                    if (!packageList.some((p) => p.includes("canary"))) {
                        return {
                            error: "No packages were changed. No canary published.",
                        };
                    }
                    return {
                        newVersion: "Canary Versions",
                        details: makeMonorepoInstallList(packageList.filter((p) => p.includes("canary"))),
                    };
                }
                const versioned = packages.find((p) => p.version.includes("canary"));
                if (!versioned) {
                    return { error: "No packages were changed. No canary published." };
                }
                const version = versioned.version.split("+")[0];
                return {
                    newVersion: this.canaryScope
                        ? `under canary scope @${sanitizeScope(this.canaryScope)}@${version}`
                        : version,
                    details: makeMonorepoInstallList(packageList),
                };
            }
            auto.logger.verbose.info("Detected single npm package");
            const current = await auto.getCurrentVersion(lastRelease);
            const { name, private: isPrivate } = await package_json_utils_1.loadPackageJson();
            if (isPrivate) {
                return {
                    error: "Package private, cannot make canary release to npm.",
                };
            }
            const canaryVersion = await findAvailableCanaryVersion(auto, name, core_1.determineNextVersion(lastRelease, current, bump, canaryIdentifier));
            if (dryRun) {
                logVersion(canaryVersion);
                return;
            }
            if (this.canaryScope) {
                await setCanaryScope(this.canaryScope, ["./"]);
            }
            await core_1.execPromise("npm", [
                "version",
                canaryVersion,
                "--no-git-tag-version",
                "--no-commit-hooks",
                ...verboseArgs,
            ]);
            const publishArgs = ["--tag", "canary"];
            await core_1.execPromise("npm", [
                "publish",
                ...getPublishFolderArgs(this.publishFolder),
                ...publishArgs,
                ...verboseArgs,
                ...getLegacyAuthArgs(this.legacyAuth),
            ]);
            if (this.canaryScope) {
                await gitReset();
            }
            auto.logger.verbose.info("Successfully published canary version");
            return {
                newVersion: canaryVersion,
                details: makeMonorepoInstallList([`${name}@${canaryVersion}`]),
            };
        });
        auto.hooks.next.tapPromise(this.name, async (preReleaseVersions, { bump, dryRun }) => {
            var _a;
            if (this.setRcToken) {
                await this.setTokenOnCI(auto);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            const lastRelease = await auto.git.getLatestRelease();
            const latestTag = (await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getLastTagNotInBaseBranch(prereleaseBranch))) ||
                (await getPreviousVersion(auto, prereleaseBranch, isMaintenanceBranch));
            if (utils_1.isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const isIndependent = utils_1.getLernaJson().version === "independent";
                // It's hard to accurately predict how we should bump independent versions.
                // So we manually make all the tags. (independent only)
                const next = isIndependent
                    ? "from-git"
                    : core_1.determineNextVersion(lastRelease, latestTag, bump, prereleaseBranch);
                auto.logger.verbose.info({
                    lastRelease,
                    latestTag,
                    bump,
                    prereleaseBranch,
                    next,
                });
                if (dryRun) {
                    if (isIndependent) {
                        const packageUpdates = await getIndependentNextReleases(bump, prereleaseBranch);
                        if (!packageUpdates || !packageUpdates.length) {
                            auto.logger.log.warn("No independent package version updates found. No canary releases would be made");
                        }
                        else {
                            packageUpdates.forEach((p) => preReleaseVersions.push(`${p.name}@${p.newVersion}`));
                        }
                    }
                    else {
                        preReleaseVersions.push(next);
                    }
                    return preReleaseVersions;
                }
                if (isIndependent) {
                    await tagIndependentNextReleases(bump, prereleaseBranch);
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    next,
                    "--dist-tag",
                    prereleaseBranch,
                    "--preid",
                    prereleaseBranch,
                    "--no-push",
                    // you always want a next version to publish
                    !isIndependent && "--force-publish",
                    ...(await getRegistryArgs()),
                    ...getPublishFolderArgs(this.publishFolder, { isMonorepo: true }),
                    ...getLegacyAuthArgs(this.legacyAuth, { isMonorepo: true }),
                    // skip prompts
                    "--yes",
                    // do not add ^ to next versions, this can result in `npm i` resolving the wrong next version
                    "--exact",
                    "--no-verify-access",
                    "--no-commit-hooks",
                    ...verboseArgs,
                ]);
                const tags = (await core_1.execPromise("git", ["tag", "--points-at", "HEAD"]))
                    .split("\n")
                    .filter((tag) => tag.trim() !== "");
                if (!this.commitNextVersion) {
                    // we do not want to commit the next version. this causes
                    // merge conflicts when merged into baseBranch. We also do not want
                    // to re-implement the magic lerna does. So instead we let lerna
                    // commit+tag the new version and roll back all the tags to the
                    // previous commit.
                    await Promise.all(
                    // Move tags back one commit
                    tags.map((tag) => core_1.execPromise("git", ["tag", tag, "-f", "HEAD^", "-am", tag])));
                    // Move branch back one commit
                    await core_1.execPromise("git", ["reset", "--hard", "HEAD~1"]);
                }
                auto.logger.verbose.info("Successfully published next version");
                preReleaseVersions = [
                    ...preReleaseVersions,
                    ...(isIndependent ? tags : tags.map(auto.prefixRelease)),
                ];
            }
            else {
                auto.logger.verbose.info("Detected single npm package");
                const newVersion = core_1.determineNextVersion(lastRelease, latestTag, bump, prereleaseBranch);
                const prefixedVersion = auto.prefixRelease(newVersion);
                preReleaseVersions.push(prefixedVersion);
                if (dryRun) {
                    return preReleaseVersions;
                }
                await core_1.execPromise("npm", [
                    "version",
                    newVersion,
                    // we do not want to commit the next version. this causes
                    // merge conflicts when merged into baseBranch
                    "--no-git-tag-version",
                    ...verboseArgs,
                ]);
                const { private: isPrivate } = await package_json_utils_1.loadPackageJson();
                await core_1.execPromise("git", [
                    "tag",
                    prefixedVersion,
                    "-m",
                    `"Update version to ${prefixedVersion}"`,
                ]);
                if (isPrivate) {
                    auto.logger.log.info(`Package private, skipping prerelease publish to npm.`);
                }
                else {
                    await core_1.execPromise("npm", [
                        "publish",
                        ...getPublishFolderArgs(this.publishFolder),
                        "--tag",
                        prereleaseBranch,
                        ...verboseArgs,
                        ...getLegacyAuthArgs(this.legacyAuth),
                    ]);
                }
                auto.logger.verbose.info("Successfully published next version");
            }
            await core_1.execPromise("git", ["push", auto.remote, branch, "--tags"]);
            return preReleaseVersions;
        });
        auto.hooks.publish.tapPromise(this.name, async () => {
            var _a;
            const status = await core_1.execPromise("git", ["status", "--porcelain"]);
            const isBaseBranch = branch === auto.baseBranch;
            // The only other time this hook is called is when creating a version
            // branch. So when on one of those branches publish to a tag of the same
            // name
            const tag = isBaseBranch
                ? []
                : [utils_1.isMonorepo() ? "--dist-tag" : "--tag", branch];
            if (isVerbose && status) {
                auto.logger.log.error("Changed Files:\n", status);
            }
            if (this.setRcToken) {
                await this.setTokenOnCI(auto);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            if (utils_1.isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                if ((_a = auto.options) === null || _a === void 0 ? void 0 : _a.verbose) {
                    await core_1.execPromise("git", ["status", "--short"]);
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    ...tag,
                    "--yes",
                    // Plugins can add as many commits as they want, lerna will still
                    // publish the changed package versions. from-git broke when HEAD
                    // didn't contain the tags
                    "from-package",
                    this.exact && "--exact",
                    ...verboseArgs,
                    ...(await getRegistryArgs()),
                    ...getPublishFolderArgs(this.publishFolder, { isMonorepo: true }),
                    ...getLegacyAuthArgs(this.legacyAuth, { isMonorepo: true }),
                    "--no-verify-access", // permit automation tokens https://github.com/lerna/lerna/issues/2788
                ]);
            }
            else {
                const { private: isPrivate } = await package_json_utils_1.loadPackageJson();
                if (isPrivate) {
                    auto.logger.log.info(`Package private, skipping publish to npm.`);
                }
                else {
                    await core_1.execPromise("npm", [
                        "publish",
                        ...getPublishFolderArgs(this.publishFolder),
                        ...tag,
                        ...verboseArgs,
                        ...getLegacyAuthArgs(this.legacyAuth),
                    ]);
                }
            }
            await core_1.execPromise("git", [
                "push",
                "--follow-tags",
                "--set-upstream",
                auto.remote,
                branch || auto.baseBranch,
            ]);
            auto.logger.verbose.info("Successfully published repo");
        });
        auto.hooks.makeRelease.tapPromise(this.name, async (options) => {
            const isIndependent = utils_1.getLernaJson().version === "independent";
            // Independent mode will create multiple releases on Github.
            // Each release will only contain the release notes for the
            // package + global changes.
            if (isIndependent) {
                const lernaPackages = await core_1.getLernaPackages();
                // Go through each new tag:
                const newTags = (await core_1.execPromise("git", ["tag", "--points-at", "HEAD"])).split("\n");
                if (options.dryRun) {
                    newTags.map(async (tag) => {
                        const lernaPackage = lernaPackages.find((p) => tag.includes(p.name));
                        if (!lernaPackage) {
                            return;
                        }
                        auto.logger.log.info(`Would have created a release on GitHub for: ${tag}`);
                    });
                    auto.logger.log.note("The above versions reflect the current git tags pointing at the HEAD commit. During the normal release flow these tags would reflect the latest released version.");
                    return [];
                }
                const packagePaths = lernaPackages.map((p) => p.path);
                const commitsAtRoot = options.commits.filter((commit) => !commit.files.some((file) => packagePaths.some((p) => core_1.inFolder(p, file))));
                auto.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);
                const changelog = await auto.release.makeChangelog();
                this.monorepoChangelog = false;
                const releases = await Promise.all(newTags.map(async (tag) => {
                    var _a;
                    const lernaPackage = lernaPackages.find((p) => tag.includes(p.name));
                    if (!lernaPackage) {
                        return;
                    }
                    auto.logger.log.info(`Releasing ${tag}...`);
                    // 1. generate release notes for just the commits for the package
                    const includedCommits = options.commits.filter((commit) => commit.files.some((file) => core_1.inFolder(lernaPackage.path, file)));
                    const releaseNotes = await changelog.generateReleaseNotes([
                        ...commitsAtRoot,
                        ...includedCommits,
                    ]);
                    auto.logger.log.info(`Using release notes:\n${releaseNotes}`);
                    // 2. make a release for just that package
                    return (_a = auto.git) === null || _a === void 0 ? void 0 : _a.publish(releaseNotes, tag, options.isPrerelease);
                }));
                this.monorepoChangelog = false;
                return releases.filter((release) => Boolean(release));
            }
        });
    }
    /** The the NPM token */
    async setTokenOnCI(auto) {
        var _a;
        try {
            await set_npm_token_1.default(auto.logger);
            // This will make NPM actually check if the npmrc is valid for the env
            await core_1.execPromise("npm", ["root"]);
        }
        catch (error) {
            if (
            // eslint-disable-next-line no-template-curly-in-string
            (_a = error.message) === null || _a === void 0 ? void 0 : _a.includes("Failed to replace env in config: ${NPM_TOKEN}")) {
                auto.logger.log.error(endent_1.default `
          Uh oh! It looks like you don\'t have a NPM_TOKEN available in your environment.

          To fix:

          - Ensure you've added a NPM_TOKEN environment variable
          - Ensure that it's exposed to your CI step
        `);
                auto.logger.verbose.error(error);
                process.exit(1);
            }
            else {
                throw error;
            }
        }
    }
}
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], NPMPlugin.prototype, "getLernaPackages", null);
exports.default = NPMPlugin;
//# sourceMappingURL=index.js.map